;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; 
;                                                                                                        ;
;                                                                                                        ;
;                                   xxxxxxxxxxxx     xxxxxxxxxx                                          ;    
;                                   xxxxxxxxxxxx    xxxxxxxxxxx                                          ;   
;                                       xxxx       xxxx    xxxx                                          ;         
;                                       xxxx       xxxx                                                  ;
;                       xxx   xxx       xxxx       xxxx                                                  ;
;                        xxx xxx        xxxx       xxxx                                                  ;  
;                         xxxxx         xxxx       xxxx   xxxxx                                          ;
;                         xxxxx         xxxx       xxxx    xxxx                                          ;
;                        xxx xxx        xxxx        xxxxxxxxxxx                                          ;
;                       xxx   xxx       xxxx         xxxxxxxxxx                                          ;
;                                                                                                        ;    
;                                                                                                        ;        
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;     
;					    eXperimental/eXtended/eXecutable Trash Generator                                 ;
;											xTG                											 ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;											:)!															 ; 
;																										 ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;										функция xTG														 ;
;			ЭКСПЕРИМЕНТАЛЬНЫЙ/РАСШИРЕННЫЙ/ИСПОЛНИМЫЙ ГЕНЕРАТОР МУСОРНЫХ ИНСТРУКЦИЙ 	 					 ;
;																										 ; 
;																										 ;
;ВХОД:																									 ;
;1 параметр (и единственный) - адрес структуры (TRASHGEN) (ее описание смотри ниже) 					 ;     
;--------------------------------------------------------------------------------------------------------;																										 ;
;ВЫХОД:																									 ;
;EAX - адрес для дальнейшей записи (если таковая будет нужна) (записи например очередного мусора etc).   ;
;А также записанная порция отменного дерьма (ака мусорных команд) по указанному адресу в указанном       ;
;размере.																				 			     ; 
;--------------------------------------------------------------------------------------------------------;
;ЗАМЕТКИ: 																								 ;
;(+) структура, указатель на которую передан в качестве параметра, не портится, т.е. данные в ней после  ;
;    вызова генератора мусора остаются теми же.       													 ; 
;(+) если нахер не нужно генерить апишки или по другой причине, то закоментить тело подфунки fakeapi. 	 ;   
;																										 ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; 
;																										 ;
;											!															 ;
;																										 ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;										ОПИСАНИЕ СТРУКТУРЫ 												 ;
;											TRASHGEN 													 ;
;																										 ;
;																										 ;
;TRASHGEN	struct																						 ;
;	rgen_addr		dd		?	;адрес Генератора Случайных Чисел (ГСЧ)									 ;
;	buf_for_trash	dd		?	;адрес (буфер), куда записывать генерируемое (хех, качественное) дерьмо	 ;
;	size_trash		dd		?	;размер (в байтах), сколько мусора записать  							 ;
;	regs			dd		?	;занятые регистры (2 шт)  												 ;
;	xmask1			dd		?	;64-битная маска для генерации  										 ;
;	xmask2			dd		?	;мусорных команд (ака фильтр)											 ;
;	beg_addr		dd		?	;начальный адрес														 ;
;	end_addr		dd		?	;конечный адрес 														 ;
;	mapped_addr		dd		?	;зарезервировано (либо база мэпинга (aka адрес файла в памяти)) 		 ;    
;	reserv1			dd		?	;зарезервировано (хз, может когда-то там что и будет) 					 ; 
;TRASHGEN	ends																						 ;
;																										 ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;											! 															 ;
;																										 ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; 
;																										 ;
;							ПОЯСНЕНИЕ К ПОЛЯМ СТРУКТУРЫ TRASHGEN: 										 ; 
;																										 ;
;																										 ;
;[   rgen_addr   ] : 																					 ; 
;					 так как данный движок (xTG) разработан без привязки к какому-либо другому мотору,	 ;
;					 а для генерации мусора важен ГСЧ, поэтому адрес ГСЧ хранится в (данном) поле 		 ;
;					 структуры. ВАЖНО: если мотор xTG будет использовать другой ГСЧ (а не тот, который 	 ;
;					 идет с ним в комплекте), надо, чтобы этот другой ГСЧ принимал в качестве 1-го 		 ;
;					 (и единственного!) параметра в стэке число (назовем его N), так как поиск будет в 	 ;
;					 диапазоне [0..n-1]. И на выходе другой ГСЧ	должен возвращать в EAX случайное число. ; 	
;					 Остальные регистры должны остаться неизменными. Все. (нихера себе все :)			 ; 
;--------------------------------------------------------------------------------------------------------; 
;[ buf_for_trash ] : 																					 ;
;					 это может быть массив etc. Думаю, тут все и так ясно.								 ; 
;--------------------------------------------------------------------------------------------------------;
;[  size_trash   ] : 																					 ;
;					 укажете например 50 байт, вот столько байт мусорных команд сгенерятся и запишутся 	 ;
;					 по	указанному адресу.																 ; 
;--------------------------------------------------------------------------------------------------------;
;[ 	   regs 	 ] : 																					 ; 
;					 здесь подразумевается, что генератор, возможно, будет использоваться вместе с 		 ;
;					 полиморфным движком. Можно указать ТОЛЬКО 2 занятых регистра. Лучше показать 		 ;
;					 пример. Вот например так может выглядеть это поле: 0x00000201. Здесь 1 занятый 	 ;
;					 регистр EDX (2), а 2-ой занятый ECX (1). Еще пример: 0x00000007. Здесь 1 занятый 	 ;
;					 регистр EAX (0), 2-ой EDI (7).	Т.е. видно, как примерно должно выглядеть это поле 	 ;
;					 в структуре. Если, к примеру, мы хотим, чтобы 1 занятый регистр был ESI (6), а 	 ;
;					 2-ой EDX (2), то поле [ regs ] будет НЕ ТАКИМ 0x00000062 (это получится бред), а 	 ;
;					 будет ТАКИМ 0x00000602. Что такое занятый регистр? Это регистры, в которых 		 ;
;					 находятся какие то значения, и эти регистры изменять ни в коем случае нельзя. 		 ;
;					 Движок xTG видит, что указаны занятые регистры, и попросту не будет их использовать ;
;					 для генерации команд, тем самым занятые регистры останутся нетронутыми 			 ;
;					 (мда, наверное это надо было написать сразу). И не надо делать идиотских push перед ;
;					 и pop после вызова движка. Я например использую этот движок (xTG) в своем полиморфе ;
;					 (он кстате тоже в комплекте:)! ). Эти занятые регистры	обычно используются в 		 ;
;					 полиморфном движке. И в союзе с данным трэш геном можно получить охуительный 		 ;
;					 результат. В общем, как всегда, кому надо, понял. 								 	 ;
; 																										 ;	
;			 		 ДЛЯ ТЕХ, КТО НИХЕРА НЕ ПОНЯЛ, МОЖНО ТУПО В ЭТОМ ПОЛЕ ВБИТЬ 0, 0xFF, 1 etc			 ;	 	
;			 		 (если неважно, что сохранится в регистрах). 										 ;		 	
;																										 ;
;			 		 ЕЩЕ: при большом желании можно данное поле расширить и на большее кол-во занятых 	 ;
;						  регистров, один из примеров этого есть в данном движке. Смотри и изучай 		 ;
;						  исходники. 																	 ;
;																										 ;
;			 		 ESP & EBP - всегда сохраняются (не изменяются). Поэтому о них можно смело забыть.	 ;		 	
;--------------------------------------------------------------------------------------------------------;
;[ 	   xmask1	 ] 																						 ;
;		 &																								 ;
;[	   xmask2	 ] : 																					 ;
;					 еще одна особенность данного движка в том, что для генерации мусора он применяет 	 ;
;					 маску (64-разрядную). Таким образом, можно генерировать только определенные 		 ;
;					 команды. Это бывает нужно, например для генерации антиэвристического мусора, или 	 ;
;					 наоборот, для пиздец хаоса. Применений куча. Сама же маска представляет собой два 	 ;
;					 32-битных числа (можно и расширить при необходимости), где каждый бит отвечает за 	 ;
;					 определенную команду. Если бит равен 1, значит, включена генерация определенной 	 ;
;					 команды. Если бит = 0, определенная команда генерироваться	не будет. Например, 	 ;
;					 пусть маска = 00000000000000001000000000100001b (xmask1) и 01b (xmask2). Видим, что ;	 	
;					 выставлены биты (начиная отсчет от 1) 1, 6 и 16 в xmask1 и 1 в xmask2. Значит, 	 ;
;					 разрешена генерация команд (INC/DEC/AAA/etc), (MOV REG32/REG16,IMM32/IMM16), 		 ;
;					 (JXX NEAR) и (NOP/CMC/CLD/etc). Т.е. 1-ый бит отвечает за генерацию 1-ой группы 	 ;
;					 команд (INC/DEC), что в табличке ниже, 16-ый бит за генерацию 16-ой группы команд 	 ;
;					 (MOV) т.д.. В общем, смотрим в табличку.		 									 ;		
;																										 ;
;			 		 ВАЖНО: самый старший бит маски (в xmask1) отвечает за хаос. 						 ;
;							За подробностями - смотри исходники.   										 ;
;																										 ;
;			 		 БУЛЬТЕ ОСТОРОЖНЫ! НЕ ИСПОЛЬЗУЙТЕ ОДНОВРЕМЕННО ГЕНЕРАЦИЮ MMX/SSE & one_byte, т.к. 	 ;
;									   это может привести к исключению. Если надо, то чередуйте их 		 ;
;									   (сначала включите одно, но выключите другое и т.д.). 			 ;
;																										 ;
;					 ЕЩЕ: лучше всегда держите включенным самый младший бит (в xmask1), чтобы все было 	 ;		
;						  супер. Иначе может произойти зацикливание.									 ;								 	
;																										 ;
;					 ДЛЯ ТЕХ, КТО НИХЕРА НЕ ПОНЯЛ, МОЖНО ТУПО В ЭТОМ ПАРАМЕТРЕ ВБИТЬ 					 ;
;					 							   0xFFFFFFFF (xmask1) и 0x00 (xmask2).  				 ;	 
;					 (если неважно, какой мусор сгенерируется).											 ;		 	
;--------------------------------------------------------------------------------------------------------;  
;[    beg_addr   ]   																					 ;
;	  	 и																								 ;	 	
;[	  end_addr	 ] :   																					 ;
;			 		 если эти параметры !=0, тогда они должны содержать реальные адреса, по которым 	 ;
;					 можно будет записывать всякую хрень. Эти адреса используются для генерации например ;
;					 такого мусора:	mov [0x004010F0],edx. Где начальный адрес например может быть таким  ;	
;					 0x00401000. А конечный 0x00402000. И все адреса в этом диапазоне могут быть 		 ;
;					 задействованы. Если же	нахер не надо таких команд генерить, тогда следует отключить ;
;					 нужный бит в маске, либо же в этих параметрах передать нули, или сделать и то и 	 ;
;					 другое.								 											 ;
;			 																							 ;
;					 ДЛЯ ТЕХ, КТО НИХЕРА НЕ ПОНЯЛ, МОЖНО ТУПО В ЭТИХ ПАРАМЕТРАХ ВБИТЬ НУЛИ.				 ;		 	
;--------------------------------------------------------------------------------------------------------; 
;[  mapped_addr  ] :																					 ; 
;					 это поле зарезервировано. Либо же сюда (можно) положить базу мэпинга (ака адрес 	 ;
;					 файла в памяти), а также в маске взвести нужный бит в 1 и расскоментировать (при 	 ;
;					 необходимости) содержимое подфункции fakeapi, которая находится в данном движке. 	 ;
;					 Это все для того, чтобы можно было генерить фэйковые апишки. 						 ;
;					 В таком случае будет произведен поиск и генерация тех апишек, которые заранее 		 ;   
;					 подготовлены в модуле [ faka.asm ] и какая-либо из этих апишек найдена в 			 ;
;					 спроецированном в память файле. Подробности по генерации фэйковых винапи читай в 	 ;
;					 [ faka.asm ] (FAKA). Вот. 													   		 ; 		
;			 																							 ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;                         
;																										 ;
;											y0p!														 ;
;																										 ;  
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;											ФИЧИ														 ;
;																										 ;
;																										 ;
;(+) генерация основных инструкций (мусорных) (1, 2, 3, 4, 5, 6 байтов)									 ;
;		* также генерация call, jmp, jxx, loop, mov/xchg/lea/cmp [address]/REG,REG/[address] etc;		 ;
;		* связка cmp/test + jxx (условный переход) - т.е. если есть cmp/test, то за ним сразу идет jxx;	 ;
;--------------------------------------------------------------------------------------------------------; 
;(+) генерация fpu/mmx/sse инструкций 																	 ;
;--------------------------------------------------------------------------------------------------------;
;(+) генерация инструкций по маске (фильтрация): 														 ;
;		* возможность генерирования антиэвристического, хуического, специального мусора, etc; 			 ;
;--------------------------------------------------------------------------------------------------------;
;(+) возможность генерировать прологи и эпилоги (отдельно или вместе)									 ;  
;--------------------------------------------------------------------------------------------------------;
;(+) возможность генерировать Fake WinApi 																 ; 
;--------------------------------------------------------------------------------------------------------; 
;(+) базонезависимость																					 ;
;--------------------------------------------------------------------------------------------------------;
;(+) нет привязки к другим движкам (ГСЧ можно юзать любой - условия читай выше;)						 ;
;		* можно компилить как самостоятельный модуль;													 ;            
;--------------------------------------------------------------------------------------------------------; 
;(+) не юзает WinAPI																					 ;
;--------------------------------------------------------------------------------------------------------;
;(X) при желании можно убрать все данные достаточно просто для мутации движка 							 ;
;																										 ; 				
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;											y0p!														 ;
;																										 ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;										ИСПОЛЬЗОВАНИЕ: 													 ;
;																										 ;
;																										 ;
;1) Подключение:																						 ;
;		xTG.asm																							 ;
;2) Вызов (пример stdcall):																				 ;
;		...																								 ;
;		szBuf		db 100 dup (00h) 																	 ;
;		...										      													 ;
;		lea		ecx,szBuf																				 ;
;		assume	ecx:ptr TRASHGEN																		 ;
;		mov		[ecx].rgen_addr,00401000h		;по этому адресу должен находиться ГСЧ					 ;
;		mov		[ecx].buf_for_trash,00402000h	;по этому адресу будем записывать мусор					 ;
;		mov		[ecx].size_trash,100			;запишем 100 байт мусора								 ;
;		mov		[ecx].regs,0203h				;нельзя использовать в мусоре регистры EDX (2) & EBX (3) ;
;		mov		[ecx].xmask1,08Fh				;по маске разрешена генерация следующих команд  		 ;
;												;(0000008fh==10001111b):								 ;
;												;inc_dec_r32, 											 ;
;												;not_neg_r32, 											 ;
;												;lea_r32_mem32, 										 ;
;												;mov_xchg_32, 											 ;
;												;add_sub_r8.											 ;
;												;остальные параметры обнулены.							 ;
;		call	xTG								;вызываем генератор мусорных команд  					 ;				 	
;																										 ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; 
;v1.0.1  




														; m1x
													;pr0mix@mail.ru
												;EOF



;========================================================================================================
;структура TRASHGEN, необходимая для данного генератора 
;========================================================================================================
TRASHGEN	struct

	rgen_addr		dd		?
	buf_for_trash	dd		?
	size_trash		dd		?
	regs			dd		?
	xmask1			dd		?
	xmask2			dd		?
	beg_addr		dd		?
	end_addr		dd		?
	mapped_addr		dd		? 
	reserv1			dd		?
	
TRASHGEN	ends
;========================================================================================================





NUM_CMD			equ		39;33					;количество возможных команд (групп команд) 
												;при добавлении нового элемента в табличку, увеличить это значение 
FOREBP			equ		1Ch 					;вспомогательная константа (для генерации команд подобных mov reg,dword ptr [ebp-0xXX] etc) 


											   


xTG:                                       		 
	pushad										;сохраняем регистры
	mov		ebp,dword ptr [esp+24h] 
	assume	ebp:ptr TRASHGEN	                                           
	call 	_delta_trash_                             
;--------------------------------------------------------------------------------------------------------
_delta_trash_:                                
	pop 	ebx									;получаем дельта-смещение
	mov		ecx,[ebp].size_trash				;в ecx сохраняем размер мусора, который надо сгенерить
	mov		edi,[ebp].buf_for_trash				;в edi - адрес, куда будем записывать этот мусор           
	cld
;--------------------------------------------------------------------------------------------------------	                                  	   
_mask_trash_:                                             
	lea 	esi,[ebx+(_table_ - _delta_trash_)]	;получаем адрес таблички, в которой хранятся расстояния (в байтах) подфункций 
	push	NUM_CMD								;количество элементов в табличке 
	call	[ebp].rgen_addr						;вызываем ГСЧ 
	cmp		eax,30								;если >30, значит будем проверять биты по 2-ой половине маски 
	jg		_2mask_
_1mask_: 	                      
	bt		[ebp].xmask1,eax					;проверяем биты по 1-ой половинке  маски (у нас маска 64-битная)  (типа фильтрация:)
	jnc		_mask_trash_						;бит не установлен?
	jmp		_gotoinstr_ 
_2mask_:
	push	eax
	sub		eax,30+1
	bt		[ebp].xmask2,eax					;проверяем биты по 2-ой половине маски 
	pop		eax
	jnc		_mask_trash_ 
_gotoinstr_:
	shl 	eax,1								;умножаем eax на 2
	add 	eax,esi								;добавляем смещение _table_
	movzx 	eax,word ptr[eax]					;считываем расстояние по полученному (случайному) смещению
	add 	eax,esi								;прибавляем его к смещению
	call 	eax									;и переходим на данную метку 
	jmp 	_mask_trash_						;по новой:)! 
;========================================================================================================
_table_:										;табличка расстояний  
	dw	(offset inc_dec_r32		 -		offset _table_)	;0		;1
	dw	(offset not_neg_r32		 -		offset _table_)	;1		;2	 	
	dw	(offset lea_r32_mem32	 -		offset _table_)	;2		;3    	
	dw	(offset mov_xchg_r32	 -		offset _table_)	;3		;4	
	dw	(offset mov_xchg_r8		 -		offset _table_)	;4		;5	    	
	dw	(offset mov_r_imm		 -		offset _table_)	;5		;6        	
	dw	(offset add_sub_r		 -		offset _table_)	;6		;7	
	dw	(offset add_sub_r8		 -		offset _table_)	;7		;8	   	
	dw	(offset add_sub_r32_imm	 -		offset _table_)	;8		;9    		
	dw	(offset shl_shr_r_imm8	 -		offset _table_)	;9		;10       				
	dw	(offset push_pop_r32_imm -		offset _table_)	;10		;11        		
	dw	(offset cmp_r_imm		 -		offset _table_)	;11		;12        		
	dw	(offset test_r			 -		offset _table_)	;12		;13        		
	dw	(offset jxx_short_down	 -		offset _table_)	;13		;14	
	dw	(offset jxx_short_up	 -		offset _table_)	;14		;15	
	dw	(offset jxx_near_down	 -		offset _table_)	;15		;16	
	dw	(offset jxx_near_up		 -		offset _table_)	;16		;17     	
	dw	(offset jmp_short		 -		offset _table_)	;17		;18            	
	dw	(offset jmp_near		 -		offset _table_)	;18		;19	
	dw	(offset call_near		 -		offset _table_)	;19		;20
    dw	(offset loopx_r32		 -		offset _table_)	;20		;21     	
	dw	(offset three_byte_r	 -		offset _table_)	;21		;22
	dw	(offset cmovx_r32		 -		offset _table_)	;22		;23	
	dw	(offset bswap_r32		 -		offset _table_)	;23		;24	
	dw	(offset mov_lea_esp		 -		offset _table_)	;24		;25        	
	dw	(offset cmp_esp			 -		offset _table_)	;25		;26	
	dw	(offset mov_lea_addr	 -		offset _table_)	;26		;27	
	dw	(offset cmp_addr		 -		offset _table_)	;27		;28	
	dw	(offset fpux 			 -		offset _table_)	;28		;29 	
	dw	(offset mmxx			 -		offset _table_)	;29		;30 	
	dw	(offset ssex			 -		offset _table_)	;30		;31
;--------------------------------------------------------------------------------------------------------
	dw	(offset one_byte		 -		offset _table_)	;0		;1
	dw	(offset setx_r8			 -		offset _table_)	;1		;2  		               

	dw	(offset prolog1			 -		offset _table_)	;2		;3 
	dw	(offset epilog1			 -		offset _table_)	;3		;4 
	dw	(offset fakeapi			 -		offset _table_)	;4		;5 
	dw	(offset mov_lea_ebp		 -		offset _table_)	;5		;6       	
	dw	(offset cmp_ebp			 -		offset _table_)	;6		;7
	dw	(offset add_sub_ebp		 -		offset _table_)	;7		;8  	 

;========================================================================================================





;===================================[ INC/DEC reg32 ]====================================================
inc_dec_r32:
	test 	ecx,ecx								;весь ли мусор уже записан
	je 		end_trash							;если да, то прекращаем генерировать команды
	push	2                       			
	call	[ebp].rgen_addr						;что будем генерить: INC/DEC ?
	shl		eax,3								;иначе генерим INC/DEC
	add		al,40h
	xchg	eax,edx	
	call 	free_reg							;вызываем функцию генерации свободного регистра (32-разрядный)                                            
	add		al,dl
	stosb										;пихаем сгенерированный опкод в буфер
	dec		ecx									;уменьшаем счетчик на размер только что сгенеренной команды
	ret											;на выход, товарищи:)!
;===================================[ INC/DEC reg32 ]====================================================





;===============================[ AAS/AAD/NOP/CLC/CLD/etc ]==============================================
one_byte:
	test	ecx,ecx
	je		end_trash 

	lea		esi,[ebx+(one_byte_opcode - _delta_trash_)]	;опкоды тянем с таблички 							   		
	call	rnd_reg								;в данном случае функция используется как ГСЧ [0;7]
	add		esi,eax
	mov		eax,[ebp].regs						;в EAX кладем занятые регистры 
	test	ah,ah								;проверяем, 1-ый занятый регистр это EAX? (bh==0 ?) 
	je		@F									;если да, то генерировать такие команды как AAA нельзя, перепрыгиваем 
	test	al,al								;проверяем, 2-ой занятый регистр это EAX? (bl==0 ?) 					
	je		@F									;etc
	bt		eax,31								;далее, смотрим, установлен ли еще и 3-ий занятый регистр?						
	jnc		_2half_								;если нет, то теперь точно можно генерить такие команды как AAA
	shr		eax,16
	cmp		al,0
	je		@F

_2half_:
	push	7;6									;можно генерить команды AAA,AAS etc (т.е. те, которые влияют на EAX)
	call	[ebp].rgen_addr						;вызываем ГСЧ 
	add		esi,eax		                			                                                     
@@:
	movsb										;пихаем в буфер полученный опкод
	dec 	ecx									;счетчик--
_1bret_:
	ret											;возврат
;===============================[ AAS/AAD/NOP/CLC/CLD/etc ]==============================================





;=======================================[ NOT/NEG reg32 ]================================================
not_neg_r32:
	cmp 	ecx,2								;проверка
	jl		inc_dec_r32							;если все записано, выходим
	mov 	al,0F7h								;иначе генерируем инструкцию NOT/NEG reg32                                      
	stosb                                               
	call 	free_reg							;получаем свободный регистр (32 разряда)
	add		al,0D0h
	xchg	eax,edx                            		
	push	2
	call	[ebp].rgen_addr						;генерим СЧ
	shl 	al,3
	add 	al,dl
	stosb										;пихаем в буфер
	dec	ecx										;счетчик-=2
	dec	ecx
	ret											;выходим
;=======================================[ NOT/NEG reg32 ]================================================





;===================[ (LEA REG32,[VALUE32])/(LEA REG32,[REG32+VALUE32]) ]================================
lea_r32_mem32:
	cmp 	ecx,6								;проверка (6 байт будет занимать такая мусорная команда)
	jl		_lret_
	mov 	al,8Dh								;если проверка успешно, пройдена - генерим данную команду (дальше аналогично все)
	stosb										;записываем 1-ый байт команды                                      
	push	2
	call	[ebp].rgen_addr						;далее случайно определяем, какая из 2-х вариантов команды будет генериться? 
	shl		eax,7
	xchg	edx,eax	
	call 	free_reg							;получаем свободный регистр (32-разрядный)
	shl 	al,3
	test	edx,edx
	je		_lmem_
	add		edx,eax
	call	free_reg
	add		eax,edx
	jmp		@F
_lmem_:
	add 	al,5 
@@:
	stosb                            
	push	-1
	call	[ebp].rgen_addr                            
	stosd                              	                                                        
	sub 	ecx,6								;вычитаем длину только что сгенерированной команды LEA (6 байт)
_lret_:
	ret											;выходим
;===================[ (LEA REG32,[VALUE32])/(LEA REG32,[REG32+VALUE32]) ]================================





;==================================[ MOV/XCHG REG32,REG32 ]==============================================  
mov_xchg_r32:
	cmp		ecx,2								;если длина генерируемой команды 
	jl		inc_dec_r32							;меньше 2, то выходим из функции 
    push	6									;иначе,
	call	[ebp].rgen_addr						;выбираем, что будет генериться? MOV(0x8B или 0x89) или XCHG ?  
	cmp		al,1
	jg		_0x8B_
	shl		eax,1
	add		al,87h
	jmp		_0x87_0x89_								
_0x8B_:
	mov		al,8bh						
_0x87_0x89_:
	stosb							
	call	free_reg			
	shl		eax,3				
	add		al,0c0h		
	xchg	edx,eax			
	call	free_reg			
	add		al,dl			
	stosb					
	dec		ecx									;счетчик-=2
	dec		ecx
	ret											;на выход
;==================================[ MOV/XCHG REG32,REG32 ]============================================== 





;===========================[ (MOV REG8,REG8/IMM8)/(XCHG REG8,REG8) ]====================================
mov_xchg_r8:
	cmp		ecx,2								;etc 
	jl		inc_dec_r32
	push	7
	call	[ebp].rgen_addr
	cmp		al,6
	je		_0xB0_
	cmp		al,1
	jg		_0x8A_
	shl		eax,1
	add		al,86h
	jmp		_0x86_0x88_
_0x8A_:
	mov		al,8Ah
_0x86_0x88_:
	stosb
	call	free_reg_r8							;здесь вызываем функцию генерацию 8-разрядного регистра 	
	shl		eax,3
	add		al,0C0h
	xchg	eax,esi
	call	free_reg_r8
	add		eax,esi
	stosb
	jmp		_mret_
;--------------------------------------------------------------------------------------------------------
_0xB0_:
	call	free_reg_r8
	add		al,0B0h
	stosb
	push	256
	call	[ebp].rgen_addr
	stosb
;--------------------------------------------------------------------------------------------------------
_mret_:	
	dec		ecx
	dec		ecx
	ret
;===========================[ (MOV REG8,REG8/IMM8)/(XCHG REG8,REG8) ]====================================





;================================[ MOV REG32/REG16,IMM32/IMM16 ]========================================= 
mov_r_imm:
	cmp		ecx,5
	jl		_m2ret_			
    push	4
	call	[ebp].rgen_addr						;будем генерить 0x66  с вероятность 1/4
	cdq
    test	eax,eax                           
    jne		_m2r32_
;--------------------------------------------------------------------------------------------------------
	mov		al,066h								;записываем префикс				
	stosb						
	xchg	eax,edx								;edx=0x66
	inc		ecx									;корректировка счетчика  
;--------------------------------------------------------------------------------------------------------
_m2r32_:
	call	free_reg							;получаем свободный 32-разрядный регистр
	add		al,0b8h						
	stosb						
	push	-1
	call	[ebp].rgen_addr						;генерим СЧ в диапазоне [0;0xffffffff)
	stosw										;И помещаем его в буфер
	cmp		dl,066h
	je		@F					
	db		0fh,0c8h							;bswap	eax			
	stosw							
@@:	        
	sub		ecx,5								;Уменьшаем счётчик на 4
_m2ret_:
	ret											;выходим
;================================[ MOV REG32/REG16,IMM32/IMM16 ]=========================================





;====================[ ADC/ADD/AND/OR/SBB/SUB/XOR REG32/REG16,REG32/REG16 ]==============================              
add_sub_r:                              	
	cmp		ecx,03h								;влезает ли ?
	jl		_aret_                                        	                                                        
	push	02h
	call	[ebp].rgen_addr						;СЧ
	test	eax,eax								;генерировать ли также 0x66?
	je		_ar32_                                         
;--------------------------------------------------------------------------------------------------------
	mov		al,66h								;мутим:)!
	stosb										;кладем в буфер
	dec		ecx									;корректировка счетчика
;--------------------------------------------------------------------------------------------------------	                                                        
_ar32_:                                            
    push	7;4									;генерим уже саму команду
	call	[ebp].rgen_addr
	shl		eax,3;04h							;с таким же успехом можно было и ебашить cmp, но это хуета, поэтому пропускаем  
	xchg	eax,edx
	push	4
	call	[ebp].rgen_addr
	or		al,1								;маленькая хитрость :)!
	add		al,dl
	stosb                                                   
	call	free_reg							;получаем свободный регистр (32 разряда)
	shl		al,03h                              
	xchg	edx,eax
	add		dl,0C0h
	call	free_reg							;получаем 2-ой свободный регистр
	add		al,dl                          
	stosb										;пихаем в буфер
	dec		ecx                      
	dec		ecx									;уменьшаем счетчик на 2 и выходим      
_aret_:
	ret	                                   
;====================[ ADC/ADD/AND/OR/SBB/SUB/XOR REG32/REG16,REG32/REG16 ]==============================              





;===========================[ ADC/ADD/AND/OR/SBB/SUB/XOR REG8,REG8 ]=====================================              
add_sub_r8:                              	
	cmp		ecx,02h								;влезает ли ?
	jl		inc_dec_r32                                        	                                                        
    push	7;4									;генерим уже саму команду (смотри выше, аналогично)
	call	[ebp].rgen_addr
	shl		eax,3;04h                              
	xchg	eax,edx
	push	4
	call	[ebp].rgen_addr
	and		al,2								;еще одна маленькая хитрость ;)
	add		al,dl
	stosb                                                   
	call	free_reg_r8							;получаем свободный регистр
	shl		al,03h                  
	add		al,0C0h                                           
	xchg	eax,esi
	call	free_reg_r8							;получаем 2-ой свободный регистр
	add		eax,esi
	stosb										;пихаем в буфер
	dec		ecx       
	dec		ecx                
	ret											;уменьшаем счетчик на 2 и выходим
;===========================[ ADC/ADD/AND/OR/SBB/SUB/XOR REG8,REG8 ]=====================================              





;==========================[ ADC/ADD/AND/OR/SBB/SUB/XOR REG32,IMM32 ]====================================              
add_sub_r32_imm:;+imm8
	cmp		ecx,6								;снова проверка
	jl		_a3ret_
	push	2
	call	[ebp].rgen_addr
	mov		esi,eax
	shl		eax,1
	add		al,81h                     			
	stosb
	push	7
	call	[ebp].rgen_addr                            			 
	shl		al,3;4 == CMP	
	xchg	edx,eax
	add		dl,0C0h
	call	free_reg							;etc 
	add		al,dl                      			
	stosb                             
	push	-1
	call	[ebp].rgen_addr                         
	test	esi,esi
	je		_a3imm32_
	stosb
	sub		ecx,3
	ret
	;add		ecx,3
	;jmp		@F 
_a3imm32_:
	stosd                              			
@@:					 
	sub		ecx,6								;Уменьшаем счётчик на 6
_a3ret_:
	ret											;выходим
;==========================[ ADC/ADD/AND/OR/SBB/SUB/XOR REG32,IMM32 ]====================================              





;======================[ RLC/RCR/ROL/ROR/SAL/SAR/SHL/SHR REG32/REG8,IMM8 ]===============================
shl_shr_r_imm8:
	cmp 	ecx,3								;проверка
	jl 		inc_dec_r32 
	push	2									;далее "случайно" определяем, какой регистр (8 или 32) будет генериться
	call	[ebp].rgen_addr
	mov		esi,eax
	add 	al,0c0h
	stosb										;и начинаем генерить данную команду
	call 	rnd_reg								;в данном случае получаем случайное число [0..7]
												;оно нам нужно для того, чтобы построить или RCL, или SHR etc
	shl		al,3								;
	add		al,0c0h
	push	eax
	test	esi,esi								;если выпала генерация команды с 8-разрядным регистром,
	jne		_sr32_
	call	free_reg_r8							;то получим свободный 8-разрядный регистр 
	jmp		@F
_sr32_:
	call	free_reg							;иначе получим свободный 32-разрядный регистр 
@@:
	pop		edx		
	add 	al,dl
	stosb										;записываем очередной байт команды
	push	31 ;32;-1							;генерим случайный байт 
	call	[ebp].rgen_addr                                
	inc		eax									;!или закоментить данную команду  
	stosb										;и пихаем его в буфер
	sub 	ecx,3								;уменьшаем счетчик на 3
	ret											;выходим
;======================[ RLC/RCR/ROL/ROR/SAL/SAR/SHL/SHR REG32/REG8,IMM8 ]===============================





;======================[ PUSH REG32/IMM8/IMM32/[esp+x] POP REG32/[esp-x] ]===============================  
push_pop_r32_imm:
	push	30									;Генерим случайное число
	call	[ebp].rgen_addr
	mov		edx,eax	
	add		al,9								;Добавляем 9 (максимальное из возможных вариков)  
	cmp		eax,ecx								;Если длина генерируемых
	jg		_pret_								;инструкций больше, чем сколько может влезть, то на выход
    push	10									;снова генерим случайное число 						
    call	[ebp].rgen_addr  
	cmp		eax,2								;выбираем, какой пуш мутить:)
	jl		_0x6A_
	je		_0x68_
	cmp		eax,4
	jl		_0xFFesp_
	je		_0xFF_
;--------------------------------------------------------------------------------------------------------
_0x50_:
	call	rnd_reg
	add		al,50h								;push reg (0x50)
	stosb                               
	jmp		@F									;прыгаем дальше 
;--------------------------------------------------------------------------------------------------------
_0x6A_:
	mov		al,6ah								;push imm8 (0х6А 0xXX)
	stosb		
	push	-1
	call	[ebp].rgen_addr					
	stosb										;Кладём в буфер
	dec		ecx									;корректируем длину реально записываемых байт 
	jmp		@F					

;--------------------------------------------------------------------------------------------------------
_0x68_:                                                   
	mov		al,68h								;push imm32 (0x68 0xXX 0xXX 0xXX 0xXX)                                           
	stosb
	push	-1
	call	[ebp].rgen_addr
	stosd
	sub		ecx,4								;корректируем
	jmp		@F
;--------------------------------------------------------------------------------------------------------
_0xFFesp_:
	mov		ax,074FFh							;push dword ptr [esp+0xXX]
	stosw
	mov		al,24h
	stosb
	push	11h
	call	[ebp].rgen_addr
	lea		esi,[eax+4]							;здесь делаем число кратным 4
	and		eax,3
	sub		esi,eax
	xchg	eax,esi 
	stosb
	sub		ecx,3
	jmp		@F 
;--------------------------------------------------------------------------------------------------------
_0xFF_:
	mov		al,0ffh								;push reg (0xff 0xf0+r) 
	stosb						
	call	rnd_reg 
	add		al,0f0h			
	stosb			
	dec		ecx
;--------------------------------------------------------------------------------------------------------
@@:                                                                         
	push	[ebp].buf_for_trash					;так как переданную структуру мы портить не будем, поэтому сначала сохраним старые значения, а новые запишем 
	push	[ebp].size_trash
	mov		[ebp].buf_for_trash,edi
	mov		[ebp].size_trash,edx
	push	ebp									;передаем адрес структуры 		
	call	xTG									;генерим порцию мусора (рекурсия)
	pop		[ebp].size_trash					;восстановим ранее сохраненные значения 
	pop		[ebp].buf_for_trash
	xchg	eax,edi
;--------------------------------------------------------------------------------------------------------
	call	rnd_reg								;далее "случайно" опрделяем, какой поп генерить 
	test	eax,eax
	jne		_0x58pop_
	mov		eax,0FC24448Fh						;pop dword ptr [esp-XX]
	stosd
	sub		ecx,3
	jmp		@F									;или	
;--------------------------------------------------------------------------------------------------------
_0x58pop_:	
	call	free_reg							;pop reg 	
	add		al,58h	
	stosb		
@@: 
	sub		ecx,edx								;Уменьшаем счётчик на edx
	dec		ecx
	dec		ecx									;еще уменьшаем счетчик 
_pret_:
	ret											;выходим
;======================[ PUSH REG32/IMM8/IMM32/[esp+x] POP REG32/[esp-x] ]=============================== 

 



;===================================[ CMP REG8/IMM8/REG32 ]==============================================
cmp_r_imm:
	cmp 	ecx,54								;54 байта = 50 байт мусора для jxx + 2 байта для jxx + 2 байта для cmp
	jl 		_cret_								;если оставшихся для записи байт не достаточно, то выходим 	 
	push	3									;иначе начинаем генерить команду
	call	[ebp].rgen_addr				
	add 	al,3ah
	stosb                                              
	call 	rnd_reg                                    
	add		al,0C0h
	xchg	eax,edx 
	call 	rnd_reg                           
	shl 	al,3                                
	add 	al,dl                               
	stosb                                              
	dec		ecx                                        
	dec		ecx
	jmp 	jxx_short_down						;после того, как команда построена, переходим на генерацию jxx (т.к. cmp без jxx - это бредняк) 
_cret_:
	ret                               
;===================================[ CMP REG8/IMM8/REG32 ]============================================== 
	                                        	 




;=====================================[ TEST REG8/REG32 ]================================================
test_r:
	cmp 	ecx,54								;смотри выше
	jl 		_tret_	 	                        
	push	2
	call	[ebp].rgen_addr						;определяем, какой из регистров будут использоваться (т.е. 8 или 32 хразрядные) 
	add 	al,84h
	stosb                                          
	call 	rnd_reg                                 
	add		al,0C0h
	xchg	eax,edx 
	call 	rnd_reg                                     
	shl 	al,3                                     
	add 	al,dl                                       
	stosb                                               
	dec		ecx                                       
    dec		ecx
	jmp 	jxx_short_down						;аналогично, смотри выше
_tret_:	                                         
	ret                                          
;=====================================[ TEST REG8/REG32 ]================================================
	                                                      
	                                                 

 

;=====================================[ JXX SHORT IMM8 ]=================================================  
jxx_short_down:									;ГЕНЕРАЦИЯ JXX SHORT прыгающего вниз (на больший адрес)          
	push	50									;Генерируем случайное число
	call	[ebp].rgen_addr
	mov		edx,eax   							                                           
	inc		eax									;добавляем длину генерируемой команды (в данном случае это короткий (2 байта) jmp)
	inc		eax									;для подобных случаев аналогично (только кол-во байтов может быть естесно другим) 
	cmp		eax,ecx								;Проверяем, влезет ли? 						
	jg		_jxxsdret_							;если нет, то выходим
;--------------------------------------------------------------------------------------------------------	    	
	push	16									;максимум есть только 16 таких коротких jmp'ов 						
	call	[ebp].rgen_addr
	add		al,70h	
	stosb				
	mov		eax,edx
	stosb							
;-------------------------------------------------------------------------------------------------------- 
	push	[ebp].buf_for_trash					;аналогично, смотри выше 
	push	[ebp].size_trash
	mov		[ebp].buf_for_trash,edi
	mov		[ebp].size_trash,edx
	push	ebp		
	
	call	xTG									;генерируем очередную партию мусора (мусор между переходом) 
	pop		[ebp].size_trash
	pop		[ebp].buf_for_trash 
	xchg	eax,edi
	dec		ecx									;Уменьшаем счётчик на 2
	dec		ecx
	sub		ecx,edx
_jxxsdret_:
	ret											;выскакиваем
;=====================================[ JXX SHORT IMM8 ]=================================================





;============[ (PUSH 0xXX POP REG32)/(MOV REG32,0xXXXXXXXX) DEC REG32 JXX SHORT IMM8 ]=================== 
jxx_short_up:									;ГЕНЕРАЦИЯ JXX SHORT прыгающий вверх (на меньший адрес)   
	push	60h									;Генерируем случайное число 
	call	[ebp].rgen_addr
	mov		edx,eax
	add		eax,2+1+5							;mov reg,value (5 byte) + dec reg (1 byte) + jxx short (2 byte) 			 
	cmp		eax,ecx								;Проверяем, влезет ли? 											
	jg		_jxxsuret_							;если нет, то выходим
;--------------------------------------------------------------------------------------------------------
	push	200h								;узнаем, на какую длину прыгнет jxx short
	call	[ebp].rgen_addr 
	xchg	eax,esi
	cmp		esi,7Fh								;и если эта длина меньше 0x80, тогда сгенерим push 0xXX pop reg
	jl		_jxxsupushpop_
;--------------------------------------------------------------------------------------------------------
_jxxsumov_:										;иначе mov reg,0xXXXXXXXX 
	call	free_reg
	push	eax
	add		al,0b8h								;MOV REG32,0xXXXXXXXX
	stosb
	xchg	eax,esi
	inc		eax	
	stosd
	dec		ecx
	dec		ecx
	jmp		@F 
;--------------------------------------------------------------------------------------------------------
_jxxsupushpop_:
	mov		al,6Ah								;PUSH 0xXX POP REG32
	stosb
	xchg	eax,esi
	inc		eax
	stosb
	call	free_reg
	push	eax
	add		eax,58h
	stosb
;--------------------------------------------------------------------------------------------------------	
@@:												;А ТЕПЕРЬ ЕЩЕ ОДИН ВАЖНЫЙ МОМЕНТ!	                      
	pop		eax
	push	eax									;optimazation!
	shl		eax,16								;т.к. 2 регистра и так трогать нельзя (они будут использованы в декрипторе), 
	add		eax,[ebp].regs						;и нам нужен еще один регистр, который трогать (временно) нельзя будет. 
												;Этот самый регистр и будет использоваться для данной комбы (т.е. mov reg32,0xXXXXXXXX dec reg jxx short)
	bts		eax,31								;а также, чтобы не случилось глюков при рекурсии, мы временно запрещаем генерить в рекурсии эту комбинацию. 
												;Потому что, при рекурсии, если выпадет генерация этой же комбы (И ПОДОБНЫХ КСТАТИ ТОЖЕ!), 
												;то нам снова надо будет тогда брать еще один регистр, а его уже и записывать некуда (иначе он сотрет предыдущий регистр), и 
												;если мы возьмем еще один регистр, то будут глюки с генерацией других команд - попросту может возникнуть так, что 
												;регистов свободных не окажется и будет бесконечный цикл и т.п. 
													 
	mov		esi,[ebp].xmask1
	and		esi,11111111111011101011111111111111b 	;вот поэтому и ставим временный запрет на генерацию в рекурсии подобных конструкций (простым обнулением нужных бит, 
												;которые и отвечают за подобные конструкции). Вооот :)! 
	;btr		esi,15;+1=16
	;btr		esi,17
	;btr		esi,23
;--------------------------------------------------------------------------------------------------------
	push	[ebp].buf_for_trash
	push	[ebp].size_trash
	push	[ebp].regs
	push	[ebp].xmask1
	push	[ebp].xmask2
	mov		[ebp].buf_for_trash,edi
	mov		[ebp].size_trash,edx
	mov		[ebp].regs,eax
	mov		[ebp].xmask1,esi
	mov		esi,[ebp].xmask2
	and		esi,11111111111111111111111111101111b	;также ставим временный запрет на генерацию фэйковых апишек (если они разрешены) 
	mov		[ebp].xmask2,esi 
	push	ebp		
			
	call	xTG									;генерируем порцию мусора 
	pop		[ebp].xmask2 
	pop		[ebp].xmask1
	pop		[ebp].regs
	pop		[ebp].size_trash
	pop		[ebp].buf_for_trash 
	xchg	eax,edi
;-------------------------------------------------------------------------------------------------------- 
	pop		eax                                                                           
	add		al,48h								;DEC REG32 
	stosb
;--------------------------------------------------------------------------------------------------------
	sub		ecx,6								;уменьшаем счетчик
	sub		ecx,edx								;etc
;--------------------------------------------------------------------------------------------------------
	add		edx,3								;+ 3 byte ( jxx short (2 byte) + dec reg32 (1 byte) )
	neg		edx									;далее с помощью нехитрой формулы вычисляем место, куда должен указывать jxx short  
;--------------------------------------------------------------------------------------------------------
	push	2									;чтобы все было тип-топ, будет генерить только JNE/JE 	 
	call	[ebp].rgen_addr
	add		al,74h
	stosb	
	xchg	eax,edx 
	stosb							
_jxxsuret_:
	ret
;============[ (PUSH 0xXX POP REG32)/(MOV REG32,0xXXXXXXXX) DEC REG32 JXX SHORT IMM8 ]===================  





;=====================================[ JXX NEAR IMM32 ]================================================= 
jxx_near_down:									;ГЕНЕРАЦИЯ JXX NEAR вниз (в сторону больших адресов)
	push	0B0h								;аналогично многое, смотри выше 
	call	[ebp].rgen_addr
	cmp		al,80h								;специально для jxx near (иначе при меньшем должен обычно генерироваться jxx short) 
	jb		jxx_near_down;jl					;типо правдаподобно ;)
	mov		edx,eax						
	add		eax,6                                        
	cmp		eax,ecx				 						
	jg		_jxxndret_	
;--------------------------------------------------------------------------------------------------------	
	mov		al,0fh								;весит 6 байт (0x0f 0x8x imm32)
	stosb										;и начинаем запихивать в буфер 
	push	16									;etc (смотри выше) 						
	call	[ebp].rgen_addr
	add		al,80h			                
	stosb						
	mov		eax,edx
	stosd						
;-------------------------------------------------------------------------------------------------------- 		
	push	[ebp].buf_for_trash
	push	[ebp].size_trash
	mov		[ebp].buf_for_trash,edi
	mov		[ebp].size_trash,edx
	push	ebp		

	call	xTG									;мусор между переходом
	pop		[ebp].size_trash
	pop		[ebp].buf_for_trash 
	xchg	eax,edi
	sub		ecx,6								;уменьшаем счетчик (коррекция его)
	sub		ecx,edx
_jxxndret_:
	ret											;выскакиваем
;=====================================[ JXX NEAR IMM32 ]================================================= 




 
;============[ (PUSH 0xXX POP REG32)/(MOV REG32,0xXXXXXXXX) DEC REG32 JXX NEAR IMM32 ]===================  
jxx_near_up:									;ГЕНЕРАЦИЯ JXX NEAR вверх (в строну младших адресов) 
	push	0B0h								;аналогично, смотри выше 
	call	[ebp].rgen_addr
	cmp		al,80h
	jb		jxx_near_up;jl
	mov		edx,eax						
	add		eax,12								;mov reg32,0xXXXXXXXX (5 byte) + dec reg32 (1 byte) + jxx near (6 byte) 
	cmp		eax,ecx				 
	jg		_jxxnuret_				 
;--------------------------------------------------------------------------------------------------------
	push	200h
	call	[ebp].rgen_addr
	xchg	esi,eax
	cmp		esi,7Fh
	jl		_jxxnupushpop_;jb 
;--------------------------------------------------------------------------------------------------------
_jxxnumov_:
	call	free_reg
	push	eax
	add		al,0B8h								;MOV REG32,0xXXXXXXXX
	stosb
	xchg	eax,esi
	inc		eax
	stosd
	dec		ecx
	dec		ecx
	jmp		@F 
;--------------------------------------------------------------------------------------------------------
_jxxnupushpop_:
	mov		al,6Ah
	stosb										;PUSH 0xXX POP REG32 
	xchg	eax,esi    
	inc		eax
	stosb
	call	free_reg
	push	eax
	add		al,58h
	stosb
;--------------------------------------------------------------------------------------------------------	
@@:
	pop		eax
	push	eax
	shl		eax,16
	add		eax,[ebp].regs;dword ptr [ebp+30h]
	bts		eax,31

	mov		esi,[ebp].xmask1
	and		esi,11111111111011101011111111111111b
	;btr		esi,17;+1=16
	;btr		esi,15
	;btr		esi,23
;--------------------------------------------------------------------------------------------------------			
	push	[ebp].buf_for_trash
	push	[ebp].size_trash
	push	[ebp].regs
	push	[ebp].xmask1
	push	[ebp].xmask2 
	mov		[ebp].buf_for_trash,edi
	mov		[ebp].size_trash,edx
	mov		[ebp].regs,eax
	mov		[ebp].xmask1,esi  
	mov		esi,[ebp].xmask2
	and		esi,11111111111111111111111111101111b	;также ставим временный запрет на генерацию фэйковых апишек (если они разрешены) 
	mov		[ebp].xmask2,esi 
	push	ebp		

	call	xTG									;мусор между переходом
	pop		[ebp].xmask2 
	pop		[ebp].xmask1
	pop		[ebp].regs
	pop		[ebp].size_trash
	pop		[ebp].buf_for_trash 
	xchg	eax,edi
;-------------------------------------------------------------------------------------------------------- 
	pop		eax
	add		al,48h								;DEC REG32
	stosb
;--------------------------------------------------------------------------------------------------------
	sub		ecx,10
	sub		ecx,edx
;--------------------------------------------------------------------------------------------------------
	add		edx,7
	neg		edx
;--------------------------------------------------------------------------------------------------------
	mov		al,0fh								;JXX NEAR                 
	stosb  
	push	2						
	call	[ebp].rgen_addr
	add		al,84h
	stosb	
	xchg	eax,edx
	stosd							
;--------------------------------------------------------------------------------------------------------        
_jxxnuret_:
	ret											;выскакиваем
;============[ (PUSH 0xXX POP REG32)/(MOV REG32,0xXXXXXXXX) DEC REG32 JXX NEAR IMM32 ]===================  





;======================================[ JMP SHORT IMM8 ]================================================ 
jmp_short:
	push	50									;аналогично, смотри выше!					
	call	[ebp].rgen_addr
	inc		eax
	mov		edx,eax
	inc		eax
	inc		eax
	cmp		eax,ecx							
	jg		_jmpsret_			
;-------------------------------------------------------------------------------------------------------- 		
	mov		al,0ebh								;и запишем короткий jmp  						
	stosb							
	mov		eax,edx
	stosb					
;-------------------------------------------------------------------------------------------------------- 
	bt		[ebp].xmask1,31						;а вот это клевая фича:)! 
	jnc		_jmpsnomask_						;сначала смотрим по маске, разрешено ли нам ее применять 
	push	-1									;если да, то...суть в следующем: сразу после джампа ставим любой байт и дальше 
	call	[ebp].rgen_addr						;все точно также: генерим сам jmp + очередную порцию мусора. 
	stosb										;А благодаря этому байту создается иллюзия, что генерятся разные команды. Вот так. 
	dec		ecx
	dec		edx
_jmpsnomask_:	
;--------------------------------------------------------------------------------------------------------			
	push	[ebp].buf_for_trash
	push	[ebp].size_trash
	mov		[ebp].buf_for_trash,edi
	mov		[ebp].size_trash,edx
	push	ebp		

	call	xTG									;мусор между переходом
	pop		[ebp].size_trash
	pop		[ebp].buf_for_trash 
	xchg	eax,edi
;--------------------------------------------------------------------------------------------------------
	dec		ecx
	dec		ecx									;уменьшаем счетчик на размер jmp short (2 byte) 
	sub		ecx,edx								;И на размер порции мусора
_jmpsret_:							
	ret											;exit
;======================================[ JMP SHORT IMM8 ]================================================




 
;======================================[ JMP NEAR IMM32 ]================================================
jmp_near:
	push	0B0h								;хех, аналогично, смотри выше 
	call	[ebp].rgen_addr
	cmp		al,7Dh
	jb		jmp_near;jl
	inc		eax
	mov		edx,eax
	add		eax,5								;JMP NEAR (0xE9 0xXX 0xXX 0xXX 0xXX = 5 byte)                                      
	cmp		eax,ecx								;сморим, хватает ли у нас байт для генерации данной команды + порции мусора для нее 	 
	jg		_jmpnret_				
;--------------------------------------------------------------------------------------------------------            
	mov		al,0e9h								;генерим и пихаем в буфер свжеиспеченный jmp near 	 
	stosb
	mov		eax,edx							
	stosd							
;--------------------------------------------------------------------------------------------------------
	bt		[ebp].xmask1,31						;смотри выше
	jnc		_jmpnnomask_
	push	-1
	call	[ebp].rgen_addr
	stosb
	dec		ecx
	dec		edx
_jmpnnomask_:	
;-------------------------------------------------------------------------------------------------------- 		
	push	[ebp].buf_for_trash
	push	[ebp].size_trash
	mov		[ebp].buf_for_trash,edi
	mov		[ebp].size_trash,edx
	push	ebp		

	call	xTG									;генерируем порцию мусора 					
	pop		[ebp].size_trash
	pop		[ebp].buf_for_trash
	xchg	eax,edi
;--------------------------------------------------------------------------------------------------------
	sub		ecx,5				
	sub		ecx,edx				
_jmpnret_:					
	ret						
;======================================[ JMP NEAR IMM32 ]================================================





;======================================[ CALL NEAR IMM32 ]===============================================
call_near:
	push	50									;аналогично, смотри выше 
	call	[ebp].rgen_addr
	mov		edx,eax								;сохраняем размер первой порции мусора  
	push	50					
	call	[ebp].rgen_addr
	inc		eax									;+1 байт для фичи (чтобы типо :) создавались разные команды после call'а 
	mov		esi,eax								;сохраним размер второй порции мусора 
	lea		eax,[eax+edx+10]					;10 byte = call near (5 byte) + push ebp (1 byte) + mov ebp,esp (2 byte) + pop ebp (1 byte) + pop reg (1 byte) 
	cmp		eax,ecx					
	jg		_callnret_
;-------------------------------------------------------------------------------------------------------- 			
	mov		al,0e8h								;генерируем и записываем call near imm32 						
	stosb						
	mov		eax,esi
	stosd						
;--------------------------------------------------------------------------------------------------------
	bt		[ebp].xmask1,31						;снова эта фича с байтом 
	jnc		_callnnomask_
	push	-1
	call	[ebp].rgen_addr
	stosb
	dec		ecx									;корректируем счетчик и размер мусора (т.к. записали этот 1 байт) 
	dec		esi
_callnnomask_:
;-------------------------------------------------------------------------------------------------------- 			
	push	[ebp].buf_for_trash
	push	[ebp].size_trash
	mov		[ebp].buf_for_trash,edi
	mov		[ebp].size_trash,esi
	push	ebp		

	call	xTG									;мусор между переходом - генерим рекурсивно
	pop		[ebp].size_trash
	pop		[ebp].buf_for_trash 
	xchg	eax,edi					
;--------------------------------------------------------------------------------------------------------    
	mov		al,55h						 
	stosb										;PUSH EBP
	mov		ax,0ec8bh							;MOV EBP,ESP  
	stosw								
;--------------------------------------------------------------------------------------------------------	
	push	[ebp].buf_for_trash
	push	[ebp].size_trash
	mov		[ebp].buf_for_trash,edi
	mov		[ebp].size_trash,edx
	push	ebp		

	call	xTG									;-||-	-||-	-||-
	pop		[ebp].size_trash
	pop		[ebp].buf_for_trash 
	xchg	eax,edi						
;-------------------------------------------------------------------------------------------------------- 
	mov		al,5dh								;POP EBP 
	stosb							 
 
	call	free_reg							;получаем свободный регистр
	add		al,58h								;добавляем базовый регистр 0x58
	stosb										;POP REG32 							
;--------------------------------------------------------------------------------------------------------  
	sub		ecx,10								;Уменьшаем счётчик на 10
	sub		ecx,edx								;Уменьшаем на размер порции мусорных команд
	sub		ecx,esi								;Уменьшаем на размер порции мусора 
_callnret_:							
	ret											;на выход:)!
;======================================[ CALL NEAR IMM32 ]=============================================== 

           
      


;======================================[ LOOP SHORT IMM8 ]===============================================
loopx_r32:										;аналогично, смотри выше ;)!       
	mov		eax,[ebp].regs
	cmp		al,1								;сначала смотрим, есть ли среди основных регистров (т.е. тех, что используются в декрипторе) ECX? 				
	je		_loopxret_							;если есть, то данную команду генерить не будет, и выходим 
	cmp		ah,1  
	je		_loopxret_
	push	50h									;иначе поехали! 
	call	[ebp].rgen_addr
	mov		edx,eax
	add		eax,2+5								;7 byte = mov ecx,0xXXXXXX (5 byte) + loop (2 byte)  
	cmp		eax,ecx								;Проверяем, влезет ли? 						
	jg		_loopxret_							;если нет, то на выход нафиг 
;--------------------------------------------------------------------------------------------------------
	push	200h
	call	[ebp].rgen_addr
	xchg	esi,eax
	cmp		esi,7Fh
	jl		_loopxpushpop_;jb
;--------------------------------------------------------------------------------------------------------
	mov		al,0b9h;ecx							;MOV ECX,0xXXXXXXXX
	stosb
	xchg	eax,esi
	inc		eax	
	stosd
	dec		ecx
	dec		ecx
	jmp		@F 
;--------------------------------------------------------------------------------------------------------
_loopxpushpop_:
	mov		al,6Ah								;PUSH 0xXX POP ECX           
	stosb
	xchg	eax,esi
	inc		eax
	stosb
	mov		al,59h
	stosb
;--------------------------------------------------------------------------------------------------------		
@@:	
	mov		eax,80010000h
	add		eax,[ebp].regs 
	;bts		eax,31
	mov		esi,[ebp].xmask1
	and		esi,11111111111011101011111111111111b
	;btr		esi,15;+1=16
	;btr		esi,17
	;btr		esi,23
;--------------------------------------------------------------------------------------------------------			
	push	[ebp].buf_for_trash
	push	[ebp].size_trash
	push	[ebp].regs
	push	[ebp].xmask1
	push	[ebp].xmask2
	mov		[ebp].buf_for_trash,edi
	mov		[ebp].size_trash,edx
	mov		[ebp].regs,eax
	mov		[ebp].xmask1,esi
	mov		esi,[ebp].xmask2
	and		esi,11111111111111111111111111101111b	;также ставим временный запрет на генерацию фэйковых апишек (если они разрешены) 
	mov		[ebp].xmask2,esi  
	push	ebp		

	call	xTG									;генерация мусорных команд 
	pop		[ebp].xmask2 
	pop		[ebp].xmask1
	pop		[ebp].regs 
	pop		[ebp].size_trash
	pop		[ebp].buf_for_trash
	xchg	eax,edi 
;--------------------------------------------------------------------------------------------------------
	sub		ecx,5
	sub		ecx,edx
;--------------------------------------------------------------------------------------------------------
	inc		edx
	inc		edx
	neg		edx
;--------------------------------------------------------------------------------------------------------
	push	3
	call	[ebp].rgen_addr
	add		al,0E0h
	stosb										;генерим LOOP SHORT IMM8 
	xchg	eax,edx
	stosb							
_loopxret_:
	ret
;======================================[ LOOP SHORT IMM8 ]===============================================





;================================[ BSF/BTR/IMUL etc REG32,REG32 ]========================================
three_byte_r:
	cmp		ecx,3								;проверка: есть байтики для записи данной команды?
	jl		_3bret_								;неудачно? тогда на выход
	mov		al,0fh								;и начинаем генерить и записывать данную команду 
	stosb                              			
	lea		esi,[ebx+(three_byte_opcode - _delta_trash_)]	;в esi - указатель на
												;табличку для генерации 3-х байтных команд						   		
	push	16
	call	[ebp].rgen_addr                                       
	add		esi,eax                    			
	movsb                              			                    	
	call	free_reg                   
	shl		eax,3			   		
	add		al,0C0h
	xchg	eax,edx 
	call	free_reg                   	
	add		al,dl                      	
	stosb                              
	sub		ecx,3								;счетчик-=3
_3bret_:
	ret											;выходим:)!
;================================[ BSF/BTR/IMUL etc REG32,REG32 ]======================================== 





;====================================[ CMOVX REG32,REG32 ]===============================================  
cmovx_r32:
	cmp		ecx,3								;проверка
	jl		_cmovxret_						
	mov		al,0fh						
	stosb							
	push	16
	call	[ebp].rgen_addr                                   
	add		al,40h						
	stosb							
	call	free_reg							;получаем свободный регистр
	shl		eax,3								;Умножаем его на 8
	add		al,0c0h				
	xchg	eax,edx 					
	call	rnd_reg								;получаем случайный регистр 							
	add		al,dl						
	stosb							
	sub		ecx,3								;Уменьшаем счётчик на 3
_cmovxret_:
	ret											;возвращаемся 
;====================================[ CMOVX REG32,REG32 ]=============================================== 





;====================================[ BSWAP REG32,REG32 ]=============================================== 
bswap_r32:
	cmp		ecx,2
	jl		inc_dec_r32
	mov		al,0Fh
	stosb
	call	free_reg
	add		al,0C8h
	stosb
	dec		ecx
	dec		ecx
	ret
;====================================[ BSWAP REG32,REG32 ]=============================================== 





;========================[ MOV/XCHG/LEA REG8/REG32,[ESP +(-) 0xXX] ]===================================== 
mov_lea_esp:									;БУДЕТ ИСПОЛЬЗОВАТЬСЯ В КАЧЕСТВЕ АНТИЭВРИСТИЧЕСКОГО МУСОРА 
	cmp		ecx,4								;проверка, есть ли еще варик записать и эту команду?
	jl		_mleret_							;если болты, то нахер отсюда
	push	1Ch									;иначе начинаем генерировать байт за байтом )
	call	[ebp].rgen_addr
	lea		esi,[eax+4]							;получаем случайное число, кратное 4
	and		eax,3
	sub		esi,eax
;--------------------------------------------------------------------------------------------------------	
	push	2									;далее случайно определяем, команды с каким разрядным (8 или 32) регистром генерить?
	call	[ebp].rgen_addr
	mov		edx,eax								;резалт сохраняем в edx (1 - 32-разрядный регистр, иначе 8-разрядный)   	
	add		eax,3
	push	eax;4								;после смотрим, какое смещение должно быть у esp (т.е. [esp+0xXX] или [esp-0xXX])
	call	[ebp].rgen_addr						;естесно, для таких команд как например xchg dword ptr [esp+0x14],edx - нельзя делать +0x14, а можно только -0x14
	shl		eax,1								;иначе сотрутся важные для нас значения в стэке 
	cmp		eax,3
	jl		@F
;--------------------------------------------------------------------------------------------------------
	push	eax
	push	2
	call	[ebp].rgen_addr						;а для таких команд как lea edx,dword ptr [esp+(-)0x14] - выбираем рандомно знак для смещения, т.к. это роли не играет 
	test	eax,eax
	pop		eax
	jne		_mlenoneg_
@@:
	neg		esi									;и меняем знак у только что сгенерированного смещения (он же 1 байт) 
;--------------------------------------------------------------------------------------------------------
_mlenoneg_:
	add		al,086h;087h						;продолжаем строить и записывать команду
	add		al,dl
	stosb
	test	edx,edx
	jne		_mler32_
	call	free_reg_r8
	jmp		@F
_mler32_:
	call	free_reg
@@:	
	shl		eax,3
	add		al,44h
	stosb
	mov		al,24h
	stosb
	xchg	eax,esi
	stosb
;--------------------------------------------------------------------------------------------------------
	sub		ecx,4
_mleret_:
	ret
;========================[ MOV/XCHG/LEA REG8/REG32,[ESP +(-) 0xXX] ]===================================== 





;=================================[ CMP REG8/REG32,[ESP +(-) 0xXX] ]===================================== 
cmp_esp:										;БУДЕТ ИСПОЛЬЗОВАТЬСЯ В КАЧЕСТВЕ АНТИЭВРИСТИЧЕСКОГО МУСОРА 
	cmp		ecx,50+4+2							;проверяем, есть ли еще место для записи данной команды (4 байта) 												
	jl		_cmpespret_							;+ jxx short (2 byte) + для этого перехода порция мусора (max 50 byte)   
	push	4									;если все тип-топ, то начинаем генерить и записывать 
	call	[ebp].rgen_addr
	add		al,38h
	stosb
	call	rnd_reg								;аналогично, смотри выше 
	shl		eax,3
	add		al,44h
	stosb
	mov		al,24h
	stosb
	push	1Ch
	call	[ebp].rgen_addr
	lea		esi,[eax+4]
	and		eax,3
	sub		esi,eax                                                                                   
	push	2
	call	[ebp].rgen_addr
	test	eax,eax
	jne		@F
	neg		esi
@@: 
	xchg	eax,esi
	stosb
	sub		ecx,4
	jmp		jxx_short_down
_cmpespret_:
	ret
;=================================[ CMP REG8/REG32,[ESP +(-) 0xXX] ]===================================== 





;=================================[ MOV/XCHG/LEA  REG8/REG32,[ADDRESS] ]=================================
mov_lea_addr:  									;БУДЕТ ИСПОЛЬЗОВАТЬСЯ В КАЧЕСТВЕ АНТИЭВРИСТИЧЕСКОГО МУСОРА 
	cmp		[ebp].beg_addr,0					;сначала проверим, в нужных параметрах нули? если да, то значит данные команды генерить не надо и выходим 				
	je		_mlaret_
	cmp		[ebp].end_addr,0
	je		_mlaret_
	mov		esi,[ebp].end_addr					;также проверим, чтобы разница между большим и меньшим адресом была >=4 ы 
	sub		esi,[ebp].beg_addr					;чтобы можно было пользоваться этим местом :) 
	sub		esi,4
	jc		_mlaret_
	cmp		ecx,6								;если все ок, теперь проверим, есть ли место в буфере (или где там) для записи этой команды? 
	jl		_mlaret_
;--------------------------------------------------------------------------------------------------------   
	push	2									;если и тут прокатило, приступим ;)! 
	call	[ebp].rgen_addr						;аналогично, смотри выше 
	mov		edx,eax	
	add		eax,3
	push	eax;4
	call	[ebp].rgen_addr
	shl		eax,1 
	add		al,086h;087h
	add		al,dl
	stosb
	test	edx,edx
	jne		_mlar32_
	call	free_reg_r8
	jmp		@F
_mlar32_:
	call	free_reg
@@:	
	shl		eax,3
	add		al,5h
	stosb
	push	esi
	call	[ebp].rgen_addr
	add		eax,[ebp].beg_addr  
	stosd
	sub		ecx,6 
_mlaret_:
	ret
;=================================[ MOV/XCHG/LEA  REG8/REG32,[ADDRESS] ]=================================





;====================================[ CMP REG8/REG32,[ADDRESS] ]======================================== 
cmp_addr:										;БУДЕТ ИСПОЛЬЗОВАТЬСЯ В КАЧЕСТВЕ АНТИЭВРИСТИЧЕСКОГО МУСОРА 
	cmp		[ebp].end_addr,0					;АНАЛОГИЧНО, СМОТРИ ВЫШЕ! 				
	je		_cmpaddrret_
	cmp		[ebp].beg_addr,0
	je		_cmpaddrret_
	mov		esi,[ebp].end_addr
	sub		esi,[ebp].beg_addr  
	sub		esi,4
	jc		_cmpaddrret_	
	cmp		ecx,50+6+2
	jl		_cmpaddrret_
;--------------------------------------------------------------------------------------------------------
	push	4
	call	[ebp].rgen_addr
	add		al,38h
	stosb
	call	rnd_reg
	shl		eax,3
	add		al,05h
	stosb
	push	esi
	call	[ebp].rgen_addr
	add		eax,[ebp].beg_addr 
	stosd
	sub		ecx,6
	jmp		jxx_short_down
_cmpaddrret_:
	ret
;====================================[ CMP REG8/REG32,[ADDRESS] ]======================================== 





;=======================================[ FPU (x87) COMMAND ]============================================ 
fpux:											;ГЕНЕРАЦИЯ FPU ИНСТРУКЦИЙ
	cmp		ecx,2
	jl		inc_dec_r32
	push	8
	call	[ebp].rgen_addr
	add		al,0D8h								;да уж ), короче смотри в маны по этим командам + отладчик + что-то еще 
	stosb
	cmp		al,0D8h
	je		_0xD8_0xDC_
	cmp		al,0DCh
	je		_0xD8_0xDC_ 
	cmp		al,0D9h
	je		_0xD9_0xDE_
	cmp		al,0DEh
	je		_0xD9_0xDE_
;--------------------------------------------------------------------------------------------------------
	push	20h
	call	[ebp].rgen_addr
	add		al,0C0h
	stosb
	jmp		_fpuxret_  
;--------------------------------------------------------------------------------------------------------
_0xD8_0xDC_:
	push	40h
	call	[ebp].rgen_addr
	add		al,0C0h
	stosb
	jmp		_fpuxret_
;--------------------------------------------------------------------------------------------------------
_0xD9_0xDE_:
	push	2
	call	[ebp].rgen_addr
	imul	eax,eax,3
	shl		eax,4
	xchg	eax,edx 	
	push	10h
	call	[ebp].rgen_addr
	add		eax,edx
	add		al,0C0h
	stosb
;--------------------------------------------------------------------------------------------------------		
_fpuxret_: 
	dec		ecx
	dec		ecx
	ret
;=======================================[ FPU (x87) COMMAND ]============================================ 





;==========================================[ MMX COMMAND ]=============================================== 
mmxx:											;ГЕНЕРАЦИЯ MMX ИНСТРУКЦИЙ
	cmp		ecx,3								;аналогично, смотри выше 
	jl		_mmxxret_
	mov		al,0Fh
	stosb
	push	2
	call	[ebp].rgen_addr
	test	eax,eax
	jne		_mmxx_opc_from_table_
	push	12;0Ch								;некоторые команды будем так генерить
	call	[ebp].rgen_addr
	add		al,60h
	stosb
	jmp		@F		
;--------------------------------------------------------------------------------------------------------			
_mmxx_opc_from_table_:							;а другие (для удобства) через табличку их байт 
	lea		esi,[ebx+(mmx_opcode - _delta_trash_)] 
	push	36
	call	[ebp].rgen_addr
	add		esi,eax
	movsb
;--------------------------------------------------------------------------------------------------------
@@: 
	call	free_reg							;стоит отметить, для свободный (не любой, а свободный!) регистр в отличие от других команд   
	add		al,0C0h								;в этих (mmx) стоит на другом месте
	xchg	eax,edx
	call	rnd_reg
	shl		eax,3 
	add		al,dl
	stosb
;-------------------------------------------------------------------------------------------------------- 
	sub		ecx,3
_mmxxret_:
	ret
;==========================================[ MMX COMMAND ]=============================================== 





;==========================================[ SSE COMMANDS ]==============================================
ssex:											;аналогично, смотри выше 
	cmp		ecx,3
	jl		_ssexret_
	mov		al,0Fh
	stosb
	push	2
	call	[ebp].rgen_addr
	test	eax,eax
	jne		_ssex_opc_from_table_
	push	0Ah;0Ch
	call	[ebp].rgen_addr
	add		al,50h
	stosb
	jmp		@F		
;--------------------------------------------------------------------------------------------------------			

_ssex_opc_from_table_:
	lea		esi,[ebx+(sse_opcode - _delta_trash_)]	
	push	26
	call	[ebp].rgen_addr
	add		esi,eax        
	movsb
;-------------------------------------------------------------------------------------------------------- 
@@:
	call	free_reg
	shl		eax,3
	add		al,0C0h
	xchg	eax,edx
	call	rnd_reg
	add		al,dl
	stosb
;--------------------------------------------------------------------------------------------------------       	 
	sub		ecx,3
_ssexret_:
	ret
;==========================================[ SSE COMMANDS ]==============================================  





;===========================================[ SETX REG8 ]================================================
setx_r8:
	cmp		ecx,3
	jl		_setxret_
	mov		al,0Fh
	stosb
	push	16
	call	[ebp].rgen_addr						;ГСЧ 
	add		al,90h
	stosb
	call	free_reg_r8
	add		al,0C0h
	stosb 
	sub		ecx,3 
_setxret_:
	ret
;===========================================[ SETX REG8 ]================================================		 





;==============================[ PUSH EBP/MOV EBP,ESP (+ SUB ESP,XX) ]=================================== 
prolog1:
	cmp		ecx,6  
	jl		inc_dec_r32 
	mov		al,55h 
	stosb
	mov		ax,0EC8Bh
	stosw
	mov		ax,0EC83h
	stosw
	push	(60h - FOREBP)  
	call	[ebp].rgen_addr 
	lea		esi,[eax + FOREBP + 8] 
	and		eax,3
	sub		esi,eax
	xchg	eax,esi
	stosb                                                                                         
 	sub		ecx,6  
_prol1ret_: 
	ret
;==============================[ PUSH EBP/MOV EBP,ESP (+ SUB ESP,XX) ]=================================== 





;================================[ (MOV EBP,ESP/POP EBP) (LEAVE) ]=======================================   
epilog1:
	cmp		ecx,3
	jl		inc_dec_r32 
	dec		ecx    
	mov		ax,0E58Bh
	stosw
	mov		al,5Dh
	stosb 
	dec		ecx
	dec		ecx   
_epil1ret_: 
	ret 
;================================[ (MOV EBP,ESP/POP EBP) (LEAVE) ]=======================================  


                  


;========================[ MOV/XCHG/LEA REG8/REG32,[EBP +(-) 0xXX] ]===================================== 
mov_lea_ebp:									;БУДЕТ ИСПОЛЬЗОВАТЬСЯ В КАЧЕСТВЕ АНТИЭВРИСТИЧЕСКОГО МУСОРА 
												;при желании можно объединить с почти такой же функцией (mo_lea_esp) 	
	cmp		ecx,3								;проверка, есть ли еще варик записать и эту команду?
	jl		_mlebpret_							;если болты, то нахер отсюда
	push	FOREBP								;иначе начинаем генерировать байт за байтом )
	call	[ebp].rgen_addr
	lea		esi,[eax+4]							;получаем случайное число, кратное 4
	and		eax,3
	sub		esi,eax
;--------------------------------------------------------------------------------------------------------	
	push	2									;далее случайно определяем, команды с каким разрядным (8 или 32) регистром генерить?
	call	[ebp].rgen_addr
	mov		edx,eax								;резалт сохраняем в edx (1 - 32-разрядный регистр, иначе 8-разрядный)   	
	add		eax,3
	push	eax;4								;после смотрим, какое смещение должно быть у ebp (т.е. [ebp+0xXX] или [ebp-0xXX])
	call	[ebp].rgen_addr						;естесно, для таких команд как например xchg dword ptr [ebp+0x14],edx - нельзя делать +0x14, а можно только -0x14
	shl		eax,1								;иначе сотрутся важные для нас значения в стэке 
	cmp		eax,3
	jl		@F
;--------------------------------------------------------------------------------------------------------
	push	eax
	push	2
	call	[ebp].rgen_addr						;а для таких команд как lea edx,dword ptr [ebp+(-)0x14] - выбираем рандомно знак для смещения, т.к. это роли не играет 
	test	eax,eax
	pop		eax
	jne		_mlebpnoneg_
@@:
	neg		esi									;и меняем знак у только что сгенерированного смещения (он же 1 байт) 
;--------------------------------------------------------------------------------------------------------
_mlebpnoneg_:
	add		al,086h;087h						;продолжаем строить и записывать команду
	add		al,dl
	stosb
	test	edx,edx
	jne		_mlebpr32_
	call	free_reg_r8
	jmp		@F
_mlebpr32_:
	call	free_reg
@@:	
	shl		eax,3
	add		al,45h 
	stosb
	xchg	eax,esi
	stosb
;--------------------------------------------------------------------------------------------------------
	sub		ecx,3 
_mlebpret_:
	ret
;========================[ MOV/XCHG/LEA REG8/REG32,[EBP +(-) 0xXX] ]=====================================  


                        


;=================================[ CMP REG8/REG32,[EBP +(-) 0xXX] ]===================================== 
cmp_ebp:										;БУДЕТ ИСПОЛЬЗОВАТЬСЯ В КАЧЕСТВЕ АНТИЭВРИСТИЧЕСКОГО МУСОРА 
												;при желании можно объединить с почти такой же функцией (cmp_esp)	 
	cmp		ecx,50+3+2							;проверяем, есть ли еще место для записи данной команды (3 байта) 												
	jl		_cmpebpret_							;+ jxx short (2 byte) + для этого перехода порция мусора (max 50 byte)   
	push	4									;если все тип-топ, то начинаем генерить и записывать 
	call	[ebp].rgen_addr
	add		al,38h
	stosb
	call	rnd_reg								;аналогично, смотри выше 
	shl		eax,3
	add		al,45h 
	stosb
	push	FOREBP 
	call	[ebp].rgen_addr
	lea		esi,[eax+4]
	and		eax,3
	sub		esi,eax                                                                                   
	push	2
	call	[ebp].rgen_addr
	test	eax,eax
	jne		@F
	neg		esi
@@: 
	xchg	eax,esi
	stosb
	sub		ecx,3 
	jmp		jxx_short_down
_cmpebpret_:
	ret
;=================================[ CMP REG8/REG32,[EBP +(-) 0xXX] ]=====================================  





;=====================[ ADC/ADD/AND/OR/SBB/SUB/XOR REG8/REG32,[EBP+(-) 0xXX] ]===========================               
add_sub_ebp:                              	          
	cmp		ecx,03h								;влезает ли ?
	jl		_asebpret_                                        	                                                        
	push	FOREBP 
	call	[ebp].rgen_addr
	lea		esi,[eax+4]
	and		eax,3
	sub		esi,eax                                                                                                                       
    push	7;4									;генерим уже саму команду
	call	[ebp].rgen_addr
	shl		eax,3;04h							;с таким же успехом можно было и ебашить cmp, но это хуета, поэтому пропускаем  
	xchg	eax,edx
	push	4
	call	[ebp].rgen_addr
	add		al,dl
	stosb    
	xchg	eax,edx 
	test	dl,2  
	je		@F  
	push	2
	call	[ebp].rgen_addr
	test	eax,eax
	jne		_asebpnoneg_ 
@@: 
	neg		esi
_asebpnoneg_: 
	test	dl,1 
	je		@F 
	call	free_reg							;получаем свободный регистр (32 разряда)
	jmp		_asebpregok_
@@: 
	call	free_reg_r8
_asebpregok_: 	         
	shl		al,03h                              
	add		al,45h                            
	stosb										;пихаем в буфер
	xchg	eax,esi
	stosb 
	sub		ecx,3       
_asebpret_:
	ret
;=====================[ ADC/ADD/AND/OR/SBB/SUB/XOR REG8/REG32,[EBP+(-) 0xXX] ]===========================
 
 



;===============================[ CALL DWORD PTR [<address>] etc ]======================================= 
;--------------------------------------------------------------------------------------------------------
;чтобы была возможность генерить фэйковые апишки, надо раскоментить эту подфункцию 
;-------------------------------------------------------------------------------------------------------- 
fakeapi:										;генерация фэйковых апишек 
;comment !	 
	jmp		_genfakeapi_ 						;вызывать данную подфунку только тогда, когда занятые регистры не EAX,ECX,EDX, а другие - так как после вызова апишек значения этих регистров может измениться. Или придумать другое 
include		faka.asm							;подключаем специальный модуль для этого 
_genfakeapi_:
	cmp		ecx,15 								;обязательно корректировать это значение, если добавляются и т.п. новые фэйковые апишки etc  
	jl		_fakeapiret_ 
	cmp		[ebp].mapped_addr,0					;если данное поле =0, то на выход  
	je		_fakeapiret_ 	 	
	xor		eax,eax 
	push	eax									;reserved1 
	push	eax									;api_va
	push	eax									;api_hash 
	push	edi									;buf_for_api
	push	[ebp].mapped_addr					;mapped_addr
	push	[ebp].rgen_addr						;rgen_addr 
	mov		edx,esp 
	assume	edx:ptr FAKEAPIGEN 		
	push	edx
	call	FAKA								;и вызываем функу генерации фэйковых апишек 
	add		esp,6*4
	mov		edi,eax								;скорректируем буфер для записи дальнейшего мусора  
	sub		eax,[edx].buf_for_api				;узнаем, сколько байт мы только что записали 
	sub		ecx,eax      						;скорректируем 
_fakeapiret_: 
		;! 	
	ret 
;===============================[ CALL DWORD PTR [<address>] etc ]=======================================

             




         
;========================================================================================================
;ВЫХОД ИЗ ГЕНЕРАТОРА МУСОРА 
;========================================================================================================

end_trash:										;выходим из генератора
	pop 	eax                                    		                  
	mov		dword ptr [esp+1Ch],edi				;сохраняем в EAX значение EDI (адрес, куда дальше записывать) 
	popad
	ret		4                                         		
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;конец функции xTG
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx





comment %   	
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;функция swap_elem
;перемешивание элементов в массиве случайным образом 
;ВХОД (stdcall) (swap_elem(DWORD *pMas,DWORD num_elem)):
;	pMas     - массив, элементы которого и надо перемешать случайным образом; 
;	num_elem - количество элементов в массиве;
;ВЫХОД:
;	(+) элементы отлично перемешаны; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  
swap_elem:
	pushad
	mov		ecx,dword ptr [esp+28h]
	mov		esi,dword ptr [esp+24h]
	xor		edx,edx
_cycleswap_: 
	push	ecx
	call	[ebp].rgen_addr  
	push	dword ptr [esi+edx*4]
	push	dword ptr [esi+eax*4]
	pop		dword ptr [esi+edx*4]
	pop		dword ptr [esi+eax*4]
	inc		edx
	cmp		edx,ecx
	jne		_cycleswap_
	popad
	ret		4*2
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;конец функции swap_elem 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
		;%  





;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;функция free_reg
;генерация свободного регистра (32-х разрядного по дефолту) 
;Выход:
;eax (al) - номер свободного регистра
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 
free_reg:
	push	edx
	mov		edx,[ebp].regs						;в EDX сохраняем регистры занятые 
_getfr_:	                                     		
	call 	rnd_reg								;вызываем функу генерации любого регистра                              		
	cmp 	al,dh								;смотрим, этот регистр уже занят (например декриптором)                                  		
	je 		_getfr_                                   	
	cmp 	al,dl								;еще одна такая проверка                                  		
	je 		_getfr_                                   	
	cmp 	al,4;esp							;также полученный только что регистр не должен быть ESP & EBP                                		
	je 		_getfr_                                   	
	cmp 	al,5;ebp                                   		
	je 		_getfr_
	bt		edx,31								;также проверяем, заняты 2 (для декриптора) или 3 регистра? (3-ий для генерации некоторых команд/конструкций) 
	jnc		_frret_								;про эти команды смотри выше 
	push	edx
	shr		edx,16
	cmp		al,dl								;если же заняты 3 регистра, то проверяем еще и его, только что полученный регистр занят?
	pop		edx 
	je		_getfr_
_frret_:										;если нет, то в EAX этот регистр и выходим 	                                 	
	pop		edx
	ret                                        		
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;конец функции free_reg
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx







;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;функция rnd_reg
;генерация случайного регистра
;Выход:
;eax (al) - номер случайного регистра
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
rnd_reg:                                          		
	push	8                                  		
	call	[ebp].rgen_addr						;вызываем ГСЧ                              		
	ret                                        		
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;конец функции rnd_reg
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 







;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;функция free_reg_r8
;генерация свободного регистра (8-ми разрядного) 
;ВЫХОД:
;EAX (al) - номер свободного регистра
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
free_reg_r8:
	push	ebx
	mov		ebx,[ebp].regs
_getfr8_:
	call	rnd_reg								;аналогично, смотри выше 
	mov		dl,al
	cmp		al,4								;смотрим, al>=4 ? если да, то вычитаем 4. Так нужно потому есть только al,cl,dl,bl,ah,ch,dh,bh
	jl		_al_etc_							;и например al & ah - имеют номера 0 и 4 соответственно и являются частью одного большого регистра EAX (AX) 
	sub		dl,4
_al_etc_:
	cmp		dl,bh
	je		_getfr8_
	cmp		dl,bl
	je		_getfr8_
	bt		ebx,31
	jnc		_frr8ret_
	push	ebx
	shr		ebx,16
	cmp		dl,bl
	pop		ebx 
	je		_getfr8_  

_frr8ret_:
	pop		ebx 
	ret
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;конец функции free_reg_r8 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
	









                          	
	                                       

;========================================================================================================			                           
;ETC 
;========================================================================================================
one_byte_opcode:								;табличка для построения однобайтовых команд 
	std                               
	cld                                
	nop                                
	clc                                			
	stc                                			
	cmc                                			
	db	0f2h									;rep
	db	0f3h									;repnz
	aaa
	aas
	cwde
	daa
	das
	lahf
;========================================================================================================
three_byte_opcode:								;табличка для построения трехбайтовых команд 
	db	002h,003h,0a3h,0a5h,0abh,0adh,0afh,0b3h 
	db	0b6h,0b7h,0bbh,0bch,0bdh,0beh,0bfh,0c1h 		 
;========================================================================================================
mmx_opcode:										;табличка для построения MMX команд 
	db	06Eh,06Fh,074h,075h,076h,07Eh,07Fh,0D1h,0D2h
	db	0D3h,0D5h,0D8h,0D9h,0DBh,0DCh,0DDh,0DFh,0E1h
	db	0E2h,0E5h,0E8h,0E9h,0EBh,0ECh,0EDh,0EFh,0F1h
	db	0F2h,0F3h,0F5h,0F8h,0F9h,0FAh,0FCh,0FDh,0FEh
;========================================================================================================
sse_opcode:										;табличка для построения SSE команд 
	db	010h,011h,012h,014h,015h,016h,028h,029h,02Ah,02Ch,02Dh,02Eh,02Fh
	db	05Ch,05Dh,05Eh,05Fh,0D7h,0DAh,0DEh,0E0h,0E3h,0E4h,0EAh,0EEh,0F6h 
;========================================================================================================







;========================================================================================================
;ДЛЯ УДОБСТВА :)! 
;======================================================================================================== 
SizeTrash			equ		$-xTG				;размер генератора мусора
;======================================================================================================== 

;Будь сильным - слабым всегда не везет!
