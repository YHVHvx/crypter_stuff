<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<META http-equiv="Content-Type" content="text/html; charset=windows-1251">
		<link rel="stylesheet" type="text/css" href="style/style.css">
		<title> Теория построения крупных p2p ботнетов </title>
	</head>

	<body>
	<table cellpadding="25" align="center" >
			<tr>
				<td>
					<h2><span class="header">Теория построения крупных p2p ботнетов</span></h2>
					<br>
					<p class="text">Как много пафоса в этих словах: <span class="warning">p2p ботнет</span>. И многие считают, что создать такой ботнет могут лишь настоящие гуру. 
Но на самом деле это не так. Главное понять <span class="warning">теорию p2p</span>. А она "ужасно" проста.</p> 
					<p class="text">Итак, главная цель - связать ip ботов между собой и передавать команды от бота к боту. 
Рассмотрим две p2p модели обмена сообщениями.</p><br>

					<h3><span class="warning">Архитектуры:</span></h3><br>
					<p class="warning">1. Временной обмен нодами (ip ботов).</p>
					<p class="text">Каждый бот хранит у себя таблицу (роутинговая таблица) со следующей структурой:</p>
					
					
					
<pre class="c" style="font-family:monospace; font-size: 80%; background: #e8e8e8;"><span style="color: #993333;">struct</span> NODE<span style="color: #009900;">&#123;</span>
	<span style="color: #993333;">uint32</span> ip<span style="color: #339933;">;</span>
	<span style="color: #993333;">uint16</span> port<span style="color: #339933;">;</span>
	<span style="color: #993333;">uint32</span> <span style="color: #000066;">time</span><span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span></pre>


					
					<p class="text">где ip - ип бота, time - время добавления бота, port - порт.</p>
					<p class="text">Пусть таблица будет ограничена размером в 255 элементов NODE [255]; т.е. максимальное число соседей бота будет 255. 
Таблица содержит уникальные IP и упорядочивается по времени. Это, например, можно сделать с помощью функции <span class="warning">qsort.</span> </p>

<PRE>
8.5.1.2 - 10:55:10 01.09.2013
1.5.1.2 - 10:53:10 01.09.2013
1.1.1.2 - 10:53:01 01.09.2013
1.1.1.2 - 06:33:10 01.09.2013
....
</PRE>

					<p class="text">Бот "смотрит" в свою таблицу, извлекает из неё последовательно элементы и отправляет сообщения с запросом нового списка. 
Бот, до которого дошло такое сообщение, отвечает актуальными ip (из вершины таблицы). Но отсылает не все 255 ип. А часть, например, 10 элементов NODE[10];
Бот, инициатор запроса нового списка ip, получает эти NODE[10], проверяет, есть ли они в его списке. 
Если да, то обновляет время. Если нет, то добавляет новые, если таблица заполнена (255 элементами) - обновляет самый "старый" элемент.</p>

					<p class="text">Таким образом, поддерживается постоянный обмен IP. Причем в таблицу заносятся актуальные IP. 
В качестве времени при передаче ip между ботами лучше передавать <span class="warning">дельту time_delta=now()-time</span>. 
Где now() - текущее время (чтобы избежать некоторых атак, 
связанных с передачей "запредельного" значения времени).</p>

					<p class="text">Вся сеть представляет один большой сегмент, в качестве координат которого будет время, и вся сеть стремится к текущему времени.<br>
					В качестве реальных примеров такой сети можно выделить <span class="warning">ZAccess</span>. Он использует как раз такую архитектуру p2p сети.</p><br> 

					<p class="warning">2. Обмен нодами по расстоянию (распределенные хеш таблицы DHT)</p>

					<p class="text">У каждого бота имеется роутинговая таблица: </p>
					
					
					
<pre class="c" style="font-family:monospace; font-size: 80%; background: #e8e8e8;"><span style="color: #993333;">struct</span> NODE<span style="color: #009900;">&#123;</span>
	<span style="color: #993333;">uint8</span> nid<span style="color: #009900;">&#91;</span><span style="color: #0000dd;">16</span><span style="color: #009900;">&#93;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">//ид ноды (бота)</span>
	<span style="color: #993333;">uint32</span> ip<span style="color: #339933;">;</span>	<span style="color: #666666; font-style: italic;">//ип</span>
	<span style="color: #993333;">uint16</span> port<span style="color: #339933;">;</span>	<span style="color: #666666; font-style: italic;">//порт</span>
	<span style="color: #993333;">uint32</span> <span style="color: #000066;">time</span><span style="color: #339933;">;</span>	<span style="color: #666666; font-style: italic;">//время</span>
<span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span></pre>



					<p class="text">Количество элементов ограничено NODE[255]. Каждый бот при своей установке генерирует ид и запоминает его - это nid, например, 
					0x00000000000000000000000000000004.<br>
					При обмене нодами бот заносит в свою роутинговую таблицу только близкие к себе nid, и только потом ориентируется на время time.</p>
					<p class="text">Допустим, есть список:</p>
					
<PRE>
0x00000000000000000000000000000000
0x00000000000000000000000000000001
0x00000000000000000000000000000002
0x00000000000000000000000000000003
0x00000000000000000000000000000005
0x00000000000000000000000000000006
0x00000000000000000000000000000007
0x00000000000000000000000000000008
</PRE>

					<p class="text">Соответственно близкими для 0x00000000000000000000000000000004 будут:</p> 
					
<PRE>
0x00000000000000000000000000000003 (4-3) = 1
0x00000000000000000000000000000005 (5-4) = 1
0x00000000000000000000000000000002 (4-2) = 2
0x00000000000000000000000000000006 (6-4) = 2
</PRE>
					
					<p class="text">и т.д.</p>
					
					<p class="text">Для работы с близкими nid нужно как-то вычислять их расстояния и потом упорядочивать. 
Для этого применяется побитовая (побайтовая) операция XOR. Давайте посмотрим, что будет, если проксорить список на 0x00000000000000000000000000000004:</p>

<PRE>
(0x00000000000000000000000000000000^0x00000000000000000000000000000004)=0x00000000000000000000000000000004
(0x00000000000000000000000000000001^0x00000000000000000000000000000004)=0x00000000000000000000000000000005
(0x00000000000000000000000000000002^0x00000000000000000000000000000004)=0x00000000000000000000000000000006
(0x00000000000000000000000000000003^0x00000000000000000000000000000004)=0x00000000000000000000000000000007
(0x00000000000000000000000000000004^0x00000000000000000000000000000004)=0x00000000000000000000000000000000
(0x00000000000000000000000000000005^0x00000000000000000000000000000004)=0x00000000000000000000000000000001
(0x00000000000000000000000000000006^0x00000000000000000000000000000004)=0x00000000000000000000000000000002
(0x00000000000000000000000000000007^0x00000000000000000000000000000004)=0x00000000000000000000000000000003
(0x00000000000000000000000000000008^0x00000000000000000000000000000004)=0x0000000000000000000000000000000С
</PRE>

					<p class="text">упорядочиваем по результату:</p>
					
<PRE>
(0x00000000000000000000000000000004^0x00000000000000000000000000000004)=0x00000000000000000000000000000000
(0x00000000000000000000000000000005^0x00000000000000000000000000000004)=0x00000000000000000000000000000001
(0x00000000000000000000000000000006^0x00000000000000000000000000000004)=0x00000000000000000000000000000002
(0x00000000000000000000000000000007^0x00000000000000000000000000000004)=0x00000000000000000000000000000003
(0x00000000000000000000000000000000^0x00000000000000000000000000000004)=0x00000000000000000000000000000004
(0x00000000000000000000000000000001^0x00000000000000000000000000000004)=0x00000000000000000000000000000005
(0x00000000000000000000000000000002^0x00000000000000000000000000000004)=0x00000000000000000000000000000006
(0x00000000000000000000000000000003^0x00000000000000000000000000000004)=0x00000000000000000000000000000007
(0x00000000000000000000000000000008^0x00000000000000000000000000000004)=0x0000000000000000000000000000000С
</PRE>

					<p class="text">Упорядочивать можно опять функцией qsort, так как у нас не используется таблиц с большим количеством элементов. 
Но, если вы планируете использовать большие роутинговые таблицы, то следует использовать бинарное дерево. </p>

					<p class="text">Таким образом, каждый бот концентрирует близкие к себе nidы. Этим сеть разбивается на множество сегментов, равных количеству ботов.<br>
					В качестве реального примера - это сеть <span class="warning">Zeus GameOver</span> (P2P).<br>
					В такой сети можно выполнять поиск nid. А если прикрепить к nid, например, файл, то и поиск определенного файла. 
Скажем, от файла считается md5 (как раз 16 байт для нашего примера) h1. 
Среди своей роутинговой таблицы ищется nid, близкий к h1 (или несколько, так как не все ноды могут быть онлайн), 
выполняется запрос к списку близких nid с запросом h1. 
Удаленная нода получает такой запрос и по своему списку ищет близкие к h1, и отправляет их обратно. 
После нескольких таких запросов, если расстояние сокращается, nid^h1 может превысить некоторое значение. 
То можно считать, что файл найден, и выполнить запрос на скачку файла с ноды. 
Таким образом, происходит поиск файлов в <span class="warning">сетях KAD.</span></p><br>
					
					<h3><span class="warning">Файлы в p2p сети:</span></h3>
					<p class="text">Рассмотренные выше типы сетей хоть и по разному, но связывают между собой ip ботов. 
А значит, боты могут отправлять сообщения своим "соседям". В качестве таких сообщений могут быть файлы. Скажем так. 
Если загрузить на одного бота файл, то он может передать его своим соседям, а они своим соседям и так далее, 
пока файл не распространится по всей сети. </p>
					<p class="text">В качестве файла может быть обновление бота, другой бот, конфигурационный файл. 
И не забудьте подписать ваши файлы цифровой подписью (приватным ключом), а при получении такого файла бот проверит его своим публичным, 
и будет знать, что его подписали именно вы. Иначе ваш ботнет быстро угонят... </p><br>

					<h3><span class="warning">Туннели (прокси):</span></h3>
					<p class="text">Из вышесказанного можно заметить, что такая сеть не имеет командного центра, а его иметь бы хотелось, для сбора статистики о ботах, 
данных формграббера, вебинжектах и прочем. И чтобы этот командный центр был скрыт за нодами.</p>
					<p class="text">Для реализации такой идеи можно в каждого бота добавить возможность туннелировать трафик. </p>
					<ol>
					<li>ботмастер выбирает среди своего списка ботов тех, которые будут туннелировать трафик;</li>
					<li>подключается к ним и отправляет подписанный цифровой подписью пакет с <span class="warning">IPcc:PORTcc</span> своего CC, превращая, 
					тем самым, бота в туннель;</li>
					<li>создает конфиг, в котором подписывает цифровой подписью <span class="warning">IPproxy:PORTproxy</span> - бота, которого он превратил в туннель;</li>
					<li>рассылает по сети конфиг стандартным способом, как для обычных файлов.</li>
					</ol>

					<p class="text">Боты начинают ломиться на туннель, который пересылает пакеты на CC:</p>

<PRE>
			bot1 ___
				|
			bot2----IPproxy:PORTproxy-->IPcc:PORTcc
				|
			bot3____|
</PRE>

					<p class="text">Обычно для обмена списками ip применяется UDP протокол, а для загрузки/скачки файлов TCP, для туннелей TCP. </p>
					<p class="text">Удачи вам в ботостроительстве.</p> 
					
					

<p class="warning"><br>______________________________<br>
pest<br> 
2013<br><br>
Inception E-Zine</p>

				</td>
			</tr>
		</table>
	</body>
</html>